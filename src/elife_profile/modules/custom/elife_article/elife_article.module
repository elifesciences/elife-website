<?php
/**
 * @file
 * Code for the eLife: Article feature.
 */

include_once 'elife_article.features.inc';

use Doctrine\Common\Annotations\AnnotationRegistry;
use Drupal\elife_article\ElifeArticleVersion;
use Drupal\elife_article\ElifeCitationService;
use Drupal\elife_article\ElifeMarkupService;
use Drupal\elife_article\ElifeXslMarkupService;
use Drupal\elife_article\MockCitationService;
use Drupal\elife_article\MockMarkupService;
use Drupal\elife_article\MockXslMarkupService;
use eLife\EIF\ArticleVersion;
use eLife\EIF\ArticleVersion\Affiliation;
use eLife\EIF\ArticleVersion\BaseContributor;
use eLife\EIF\ArticleVersion\Citation;
use eLife\EIF\ArticleVersion\Citation\Author;
use eLife\EIF\ArticleVersion\Contributor;
use eLife\EIF\ArticleVersion\Contributor\PersonContributor;
use eLife\EIF\ArticleVersion\Contributor\PersonContributor\BylineContributor;
use eLife\EIF\ArticleVersion\Contributor\CollabContributor;
use eLife\EIF\ArticleVersion\Contributor\OnBehalfOfContributor;
use eLife\EIF\ArticleVersion\Contributor\PersonContributor\NonBylineContributor;
use eLife\EIF\ArticleVersion\Fragment;
use eLife\EIF\ArticleVersion\Referenced;
use eLife\EIF\ArticleVersion\Referenced\FootNote;
use eLife\EIF\ArticleVersion\Referenced\Funding;
use eLife\EIF\ArticleVersion\Referenced\RelatedObject;
use eLife\EIF\ArticleVersion\RelatedArticle;
use eLife\EIF\ArticleVersion\SubArticle;
use eLife\EIF\JMSJsonSerializer;
use eLife\EIF\JMSJsonSerializer\ContributorHandler;
use eLife\EIF\JMSJsonSerializer\DefaultValueExclusionStrategy;
use eLife\EIF\JMSJsonSerializer\FragmentHandler;
use eLife\EIF\JMSJsonSerializer\SubArticleSubscriber;
use eLife\EIF\JsonSerializer;
use eLife\EIF\JsonValidator;
use eLife\EIF\NodeJsonValidator;
use JMS\Serializer\DeserializationContext;
use JMS\Serializer\EventDispatcher\EventDispatcher;
use JMS\Serializer\Handler\DateHandler;
use JMS\Serializer\Handler\HandlerRegistry;
use JMS\Serializer\SerializationContext;

/**
 * Implements hook_module_implements_alter().
 */
function elife_article_module_implements_alter(&$implementations, $hook) {
  if (!isset($implementations['elife_article'])) {
    return;
  }

  switch ($hook) {
    case 'entitycache_node_load':
      // Immediately after Disqus.
      $group = $implementations['elife_article'];
      unset($implementations['elife_article']);
      $implementations['elife_article'] = $group;
      $group = $implementations['elife_article'];
      unset($implementations['elife_article']);
      $disqus = array_search('disqus', array_keys($implementations));
      $old_implementations = $implementations;
      $implementations = array_slice($old_implementations, 0, $disqus + 1, TRUE) +
        ['elife_article' => $group] +
        array_slice($old_implementations, $disqus + 1, NULL, TRUE);
      break;
  }
}

/**
 * Implements hook_menu().
 */
function elife_article_menu() {
  $items = array();
  $items['admin/config/search/elife-article-markup'] = array(
    'title' => 'Transfer Markup to cache',
    'access arguments' => array('administer elife_article'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('elife_article_markup_prepopulate_form'),
    'type' => MENU_NORMAL_ITEM,
    'file' => 'elife_article.admin.inc',
  );
  $items['admin/config/services/elife-eif-json'] = array(
    'title' => 'Populate EIF Json field',
    'access arguments' => array('administer elife_article'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('elife_article_eif_json_prepopulate_form'),
    'type' => MENU_NORMAL_ITEM,
    'file' => 'elife_article.admin.inc',
  );
  $items['admin/config/search/elife-rewrite-latest-paths'] = array(
    'title' => 'Process new article paths for most recent article versions',
    'access arguments' => array('administer elife_article'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('elife_article_rewrite_latest_paths_form'),
    'type' => MENU_NORMAL_ITEM,
    'file' => 'elife_article.admin.inc',
  );
  $items['admin/config/services/elife-article-assets-source'] = array(
    'title' => 'eLife Assets Source',
    'description' => 'Configuration options for eLife assets source.',
    'access arguments' => array('administer elife_article assets source'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('elife_article_assets_source_settings_form'),
    'type' => MENU_NORMAL_ITEM,
    'file' => 'elife_article.admin.inc',
  );
  $items['admin/config/services/elife-article-resolve-duplicates'] = array(
    'title' => 'eLife resolve duplicates',
    'description' => 'Resolve duplicate elife_article and elife_article_reference nodes.',
    'access arguments' => array('resolve elife_article duplicates'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('elife_article_resolve_duplicates_form'),
    'type' => MENU_NORMAL_ITEM,
    'file' => 'elife_article.admin.inc',
  );
  $items['admin/config/services/elife-article-versions-cleanup'] = array(
    'title' => 'eLife resolve version ordering',
    'description' => 'Make sure that the weight of versions of an article goes up in sequence from 0',
    'access arguments' => array('resolve elife_article version ordering'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('elife_article_resolve_version_ordering_form'),
    'type' => MENU_NORMAL_ITEM,
    'file' => 'elife_article.admin.inc',
  );
  $items['elife/citation'] = array(
    'title' => 'Stream file from backend',
    'page callback' => 'elife_article_citation_download',
    'page arguments' => array(2, 3),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['lookup/doi'] = array(
    'title' => 'Lookup from doi',
    'page callback' => 'elife_article_lookup_doi',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['content'] = array(
    'title' => 'Lookup from content alias without version number',
    'page callback' => 'elife_article_lookup_content',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['node/%node/elife_markup_clear'] = array(
    'title' => 'Clear markup',
    'page callback' => '_elife_article_markup_clear',
    'page arguments' => array(1),
    'access arguments' => array('clear elife_article markup'),
    'weight' => 0,
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_PAGE,
  );
  return $items;
}

/**
 * Handle the generic content path request.
 *
 * Forward to the latest article version main or fragment page if found.
 */
function elife_article_lookup_content() {
  $redirect = FALSE;
  $http_response_code = 301;
  $raw_path = 'content/' . implode('/', func_get_args());

  // If the path matches an old pdf link the redirect to the latest pdf.
  if (preg_match('/^content\/(elife\/)?(?P<volume>[0-9]+)\/(?P<eloc_id>e[0-9]{5})\.full\.pdf$/', $raw_path, $match)) {
    if ($source = drupal_lookup_path('source', sprintf('content/%s/%s', $match['volume'], $match['eloc_id']))) {
      $article_version = menu_get_object('node', 1, $source);
      $redirect = elife_article_version_source_pdf_local($article_version);
    }
  }
  // Detect request for article PDF.
  elseif (preg_match('/^(?P<root_path>content\/[0-9]+\/)(?P<file_name>e[0-9]{5}(v[0-9]+)?)(?P<download>\-download)?(?P<ext>.pdf)$/', $raw_path, $match)) {
    if ($source = drupal_lookup_path('source', $match['root_path'] . $match['file_name'])) {
      $article_version = menu_get_object('node', 1, $source);
      $pdf_path = elife_article_version_source_pdf_path($article_version, (!empty($match['download'])));
      $pdf_head = array_change_key_case(get_headers($pdf_path, TRUE));
      $context = stream_context_create(array('http' => array('timeout' => DEFAULT_HTTP_TIMEOUT)));
      if (!empty($pdf_head['content-length']) && $file = @fopen($pdf_path, 'rb', false, $context)) {
        $pdf_filesize = $pdf_head['content-length'];
        if (!empty($match['download'])) {
          $disposition = 'attachment';
          $match['file_name'] .= $match['download'];
        }
        else {
          $disposition = 'inline';
        }
        drupal_add_http_header('Content-type', 'application/pdf');
        drupal_add_http_header('Content-Disposition', sprintf('%s; filename="%s"', $disposition, $match['file_name'] . $match['ext']));
        drupal_add_http_header('Content-Length', $pdf_filesize);
        drupal_send_headers();
        while (!feof($file)) {
          print(@fread($file, 1024*8));
          ob_flush();
          flush();
        }
        exit();
      }
      else {
        throw new Exception("Error opening: {$pdf_path}");
      }
    }
  }
  // Detect request for figures PDF.
  elseif (preg_match('/^(?P<root_path>content\/[0-9]+\/)(?P<file_name>e[0-9]{5}(v[0-9]+)?)(?P<download>\-download)?(?P<ext>.figures.pdf)$/', $raw_path, $match)) {
    if ($source = drupal_lookup_path('source', $match['root_path'] . $match['file_name'])) {
      $article_version = menu_get_object('node', 1, $source);
      $figures_pdf_path = elife_article_version_source_figures_pdf_path($article_version, (!empty($match['download'])));
      $figures_pdf_head = array_change_key_case(get_headers($figures_pdf_path, TRUE));
      $context = stream_context_create(array('http' => array('timeout' => DEFAULT_HTTP_TIMEOUT)));
      if (!empty($figures_pdf_head['content-length']) && $file = @fopen($figures_pdf_path, 'rb', false, $context)) {
        $figures_pdf_filesize = $figures_pdf_head['content-length'];
        if (!empty($match['download'])) {
          $disposition = 'attachment';
          $match['file_name'] .= $match['download'];
        }
        else {
          $disposition = 'inline';
        }
        drupal_add_http_header('Content-type', 'application/pdf');
        drupal_add_http_header('Content-Disposition', sprintf('%s; filename="%s"', $disposition, $match['file_name'] . $match['ext']));
        drupal_add_http_header('Content-Length', $figures_pdf_filesize);
        drupal_send_headers();
        while (!feof($file)) {
          print(@fread($file, 1024*8));
          ob_flush();
          flush();
        }
        exit();
      }
      else {
        throw new Exception("Error opening: {$figures_pdf_path}");
      }
    }
  }
  // If the path matches an old xml link the redirect to the latest xml.
  elseif (preg_match('/^(?P<root_path>content\/)(elife\/)?(?P<volume>[0-9]+)\/(?P<eloc_id>e[0-9]{5})\.source\.xml$/', $raw_path, $match)) {
    if ($source = drupal_lookup_path('source', $match['root_path'] . $match['volume'] . '/' . $match['eloc_id'])) {
      $article_version = menu_get_object('node', 1, $source);
      $redirect = elife_article_version_source_xml_path($article_version);
      $http_response_code = 302;
    }
  }
  elseif (preg_match('/^content\/(?P<volume>[0-9]+)\/(?P<eloc_id>e[0-9]{5})v(?P<version>[0-9]+)(\/[^\/]+){0,}$/', $raw_path, $match)) {
    if ($source = drupal_lookup_path('source', sprintf('content/%s/%s', $match['volume'], $match['eloc_id']))) {
      $article_version = menu_get_object('node', 1, $source);
      $dto = elife_article_version_to_dto($article_version);
      $versions = ElifeArticleVersion::fromId($dto->getArticleId(), FALSE);
      $latest_version = 0;
      if (!empty($versions)) {
        $latest = reset($versions);
        $latest_version = $latest->extraFields->field_elife_a_version_version;
      }
      // If version number in url matches latest version and if the path matches a
      // path in our database but without a version then redirect to the same path
      // but with the latest version inserted.
      if ($match['version'] == $latest_version) {
        $alias = preg_replace('/^(content\/[0-9]+\/e[0-9]{5})v[0-9]+(.*)/', '$1$2', $raw_path);
        if ($source_path = drupal_lookup_path('source', $alias)) {
          if (!empty($_GET['panels_ajax_tab_trigger'])) {
            $redirect = $alias . '/' . $_GET['panels_ajax_tab_trigger'];
          }
          else {
            $redirect = $source_path;
          }
          $http_response_code = 302;
        }
      }
    }
  }

  if ($redirect) {
    drupal_goto($redirect, [], $http_response_code);
  }
  else {
    drupal_not_found();
    exit();
  }
}

/**
 * Handle internal doi lookup request.
 *
 * Redirect to latest article version main or fragment page or if the doi is not
 * recognised then forward the user to crossref.
 *
 * @return null|string
 */
function elife_article_lookup_doi() {
  $doi = implode('/', func_get_args());
  if ($path = _elife_article_lookup_doi_path_cache($doi)) {
    drupal_goto($path, [], 301);
  }
  else {
    drupal_set_title('DOI Not Found');
    header('HTTP/1.0 404 Not Found');

    $redirection_url_path = 'http://dx.doi.org/' . $doi;

    // Time interval to send on dx.doi.
    $time_interval = variable_get('elife_article_doi_redirect_time_interval', 8);

    // Adds settings to Drupal.settings.
    $doi_settings = array(
      'doi_redirection' => array(
        'url' => $redirection_url_path,
        'count' => $time_interval,
      ),
    );
    drupal_add_js($doi_settings, 'setting');

    drupal_add_js(drupal_get_path('module', 'elife_article') . '/js/elife_article_lookup_doi.js', array('scope' => 'footer'));

    // Redirection path.
    $options = array(
      'absolute' => TRUE,
    );
    $redirection_url = l(t('here'), $redirection_url_path, $options);

    $args = array(
      '@time_interval' => $time_interval,
      '!redirection_url' => $redirection_url,
    );

    $output = t('<div id="doi_dialog">No resource with that DOI could be found on this site. Sending you to the original source in <span id="doi_countdown">@time_interval</span>. You may also click !redirection_url.</div>', $args);
    return $output;
  }
}

function _elife_article_lookup_doi_path_cache($doi) {
  $key = 'elife_article_lookup_doi_path_'.$doi;

  $found = cache_get($key);

  if(!$found) {
    if($found = _elife_article_lookup_doi_path($doi)) {
      cache_set($key, $found);
    }
  } else {
    $found = $found->data;
  }

  return $found;
}

/**
 * Get alias for latest article version from doi.
 *
 * @param string $doi
 *
 * @return null|string
 */
function _elife_article_lookup_doi_path($doi) {
  $doi_prefix = '10.7554/eLife.';
  if (preg_match('/^' . preg_quote($doi_prefix, '/') . '(?<article_id>[0-9]{5})(?<variant>\.[0-9]{3})?$/', $doi, $match)) {
    if ($article_version = ElifeArticleVersion::latestFromDoi($doi_prefix . $match['article_id'])) {
      $dto = elife_article_version_to_dto($article_version);
      if (empty($match['variant'])) {
        return drupal_get_path_alias('node/' . $article_version->nid);
      }
      elseif ($dto->getFragment($doi)) {
        $fragment_query = new EntityFieldQuery();
        $fragment_query->entityCondition('entity_type', 'node');
        $fragment_query->entityCondition('bundle', ['elife_fragment', 'elife_article_ver'], 'IN');
        $fragment_query->fieldCondition('field_elife_a_doi', 'value', $doi, '=');
        $fragment_query->fieldCondition('field_elife_a_parent', 'target_id', $article_version->nid, '=');
        $fragment_query->range(0, 1);
        $fragments = $fragment_query->execute();
        if (!empty($fragments['node'])) {
          $fragments = array_keys($fragments['node']);
          return drupal_get_path_alias('node/' . $fragments[0]);
        }
      }
    }
  }
}

/**
 * Handle the request for the bibtex or ris citation format.
 *
 * @param int $nid
 *   Node if of article version
 * @param string $format
 *   bibtex or ris - citation format
 */
function elife_article_citation_download($nid, $format) {
  $article_version = node_load($nid);
  $dto = elife_article_version_to_dto($article_version);

  $article_version_id = $dto->getArticleVersionId();

  $citation = elife_article_citation_service();
  $citation->setId($article_version_id);
  $citation = _elife_article_citation_query($citation);

  switch ($format) {
    case 'bibtex':
      $ext = 'bib';
      drupal_add_http_header('Content-Type', 'application/x-bibtex; charset=utf-8');
      break;

    case 'ris':
      $ext = 'ris';
      drupal_add_http_header('Content-Type', 'application/x-research-info-systems');
      break;

    default:
      drupal_not_found();
      exit();
  }

  $filename = str_replace(' ', '-', strtolower(check_plain($article_version->title))) . '.' . $ext;

  drupal_add_http_header('Cache-Control', 'max-age=60, must-revalidate');
  drupal_add_http_header('Content-Disposition', 'attachment; filename="' . $filename . '"');
  echo $citation->getFormat($format);
}

/**
 * Implements hook_permission().
 */
function elife_article_permission() {
  return array(
    'administer elife_article' => array(
      'title' => t('Administer eLife - Article'),
    ),
    'administer elife_article assets source' => array(
      'title' => t('Administer eLife - Article assets source'),
    ),
    'clear elife_article markup' => array(
      'title' => t('Clear eLife HTML and citation markup'),
    ),
    'resolve elife_article duplicates' => array(
      'title' => t('Resolve elife_article and elife_article_reference duplicate nodes'),
    ),
    'resolve elife_article version ordering' => array(
      'title' => t('Resolve elife_article version ordering (follows sequence from 0)'),
    ),
  );
}

/**
 * Implements hook_node_delete().
 */
function elife_article_node_delete($node) {
  if ('elife_article_ver' === $node->type) {
    db_delete('field_data_field_elife_a_versions')
      ->condition('entity_type', 'node', '=')
      ->condition('bundle', 'elife_article', '=')
      ->condition('field_elife_a_versions_target_id', $node->nid, '=')
      ->execute();
  }
}

/**
 * Implements hook_node_view().
 */
function elife_article_node_view($node, $view_mode, $langcode) {
  if (
    'elife_article_ver' === $node->type
    &&
    in_array($view_mode, ['teaser', 'elife_teaser_compact'])
  ) {
    $node->content['#attached']['css'][] = drupal_get_path('module', 'elife_article') . '/css/article-teaser.css';
  }
}

/**
 * Implements hook_node_view_alter().
 */
function elife_article_node_view_alter(&$build) {
  // We don't want to see elife_article anywhere, so replace it with the first
  // elife_article_ver.
  if ('elife_article' === $build['#bundle'] && !empty($build['#node']->field_elife_a_versions)) {
    $version = node_load($build['#node']->field_elife_a_versions[LANGUAGE_NONE][0]['target_id']);

    if ($version) {
      $build = node_view($version, $build['#view_mode'], $build['#language']);
    }
  }
}

/**
 * Implements template_preprocess_node().
 */
function elife_article_preprocess_node(&$variables) {
  if ('elife_article_ver' === $variables['type'] && in_array($variables['view_mode'], [
      'teaser',
      'elife_teaser_compact',
    ])
  ) {
    $variables['date'] = format_date($variables['node']->created, 'custom', 'j F Y');

    $dto = elife_article_version_to_dto($variables['node']);

    $contributors = $dto->getContributors();
    $contributor_items = [];
    if (!empty($contributors)) {
      foreach ($contributors as $co => $contributor) {

        if ($contributor instanceof BylineContributor) {
          if ('author' !== $contributor->getType()) {
            continue;
          }
          // Ok.
        }
        elseif ($contributor instanceof CollabContributor) {
          // Ok.
        }
        elseif ($contributor instanceof OnBehalfOfContributor) {
          // Ok.
        }
        else {
          continue;
        }

        $contributor_items[] = $contributor;
      }
    }

    if (!empty($contributor_items)) {
      $full_items = [];
      $short_items = [];

      foreach ($contributor_items as $contributor_item) {
        if (!empty($contributor_item->getName())) {
          $full_items[] = [
            'data' => $contributor_item->getName(),
            'class' => ['author-list__item'],
          ];
        }
        if (!empty($contributor_item->getShortName())) {
          $short_items[] = [
            'data' => $contributor_item->getShortName(),
            'class' => ['author-list__item'],
          ];
        }
      }

      if (!empty($full_items)) {
        $variables['elife_a_contributors'] = theme('item_list', [
          'items' => $full_items,
          'type' => 'ul',
          'title' => '',
          'attributes' => [
            'class' => [
              'article-teaser__author-list',
              'author-list',
            ],
          ],
        ]);
      }

      if (!empty($short_items)) {
        $variables['elife_a_contributors_short'] = theme('item_list', [
          'items' => $short_items,
          'type' => 'ul',
          'title' => '',
          'attributes' => [
            'class' => [
              'article-teaser__author-list',
              'author-list',
            ],
          ],
        ]);
      }
    }

    $meta_parts = [];

    $display_channel = NULL;

    if (!empty($variables['field_elife_a_category'][LANGUAGE_NONE])) {
      foreach ($variables['field_elife_a_category'][LANGUAGE_NONE] as $i => $term) {
        $term_entity = taxonomy_term_load($term['target_id']);

        if ('display-channel' === $term_entity->field_elife_category_type[LANGUAGE_NONE][0]['value']) {
          $display_channel = $term_entity;
          break;
        }
      }
    }

    if (!empty($display_channel)) {
      $meta_parts[] = l($display_channel->field_elife_title[LANGUAGE_NONE][0]['safe_value'], 'taxonomy/term/' . $display_channel->tid, [
        'html' => TRUE,
        'attributes' => [
          'class' => [
            'article-teaser__meta_part',
            'article-teaser__category',
            'article-teaser__category--' . preg_replace('/[^a-z]+/', '-', strtolower($display_channel->name)),
          ],
        ],
      ]);
    }

    if (!empty($variables['field_elife_a_heading'][LANGUAGE_NONE])) {
      foreach ($variables['field_elife_a_heading'][LANGUAGE_NONE] as $i => $term) {
        $term_entity = taxonomy_term_load($term['target_id']);

        $meta_parts[] = l($term_entity->field_elife_title[LANGUAGE_NONE][0]['safe_value'], 'taxonomy/term/' . $term_entity->tid, [
          'html' => TRUE,
          'attributes' => [
            'class' => [
              'article-teaser__meta_part',
              'article-teaser__heading',
            ],
          ],
        ]);
      }
    }

    if (!empty($meta_parts)) {
      $variables['elife_a_meta_compact'] = '<div class="article-teaser__meta">' . implode(' ', $meta_parts) . '</div>';
    }

    if (!empty($dto->getPubDate())) {
      $meta_parts[] = '<time class="article-teaser__meta_part article-teaser__datestamp" datetime="' . $dto->getPubDate()->format('Y-m-d') . '">Published on ' . $dto->getPubDate()->format('F j, Y') . '</time>';
      if (!empty($dto->getUpdate()) &&
        $dto->getPubDate()->format('Ymd') < $dto->getUpdate()->format('Ymd')
      ) {
        $meta_parts[] = '<time class="article-teaser__meta_part article-teaser__datestamp" datetime="' . $dto->getUpdate()->format('Y-m-d') . '">Updated on ' . $dto->getUpdate()->format('F j, Y') . '</time>';
      }
    }

    if (!empty($meta_parts)) {
      $variables['elife_a_meta'] = '<div class="article-teaser__meta">' . implode(' ', $meta_parts) . '</div>';
    }
  }

  $node = $variables['node'];

  if ('elife_article_ver' === $variables['type']) {
    switch ($node->field_elife_a_status[LANGUAGE_NONE][0]['value']) {
      case 'POA':
        $variables['elife_a_status_text'] = '<span class="article-teaser__status_text">Accepted manuscript</span>';
        break;
      case 'VOR':
        $lens_url = sprintf('http://lens.elifesciences.org/%s/index.html', $node->field_elife_a_article_id[LANGUAGE_NONE][0]['value']);
        $variables['elife_a_lens_link'] = '<div class="article-teaser__lens_link">' . l('View in eLife Lens', $lens_url) . '</div>';
        break;
    }
  }

  $variables['submitted'] = t('Created !created-date and last modified on !changed-date', array(
    '!created-date' => format_date($node->created),
    '!changed-date' => format_date($node->changed),
  ));
}

/**
 * Implements hook_entitycache_node_load().
 */
function elife_article_entitycache_node_load($nodes) {
  foreach ($nodes as $node) {
    if ('elife_article_ver' !== $node->type || empty($node->field_elife_a_article_id[LANGUAGE_NONE]) || empty($node->disqus)) {
      continue;
    }
    if (preg_match('/^(?P<canonical_url>\/content\/[0-9]+\/e[0-9]+)/', url('node/' . $node->nid), $match)) {
      $node->disqus['url'] = url($match['canonical_url'], ['absolute' => TRUE]);
    }
    $node->disqus['identifier'] = 'article:' . $node->field_elife_a_article_id[LANGUAGE_NONE][0]['value'];
  }
}

/**
 * Implements hook_token_info().
 */
function elife_article_token_info() {
  $info['tokens']['node']['version_no'] = array(
    'name' => t('Version number'),
    'description' => t('Version number of article as integer.'),
  );
  $info['tokens']['node']['eloc_id'] = array(
    'name' => t('elocation ID of article'),
    'description' => t("The identifier of an article as a string of 5 digits with a leading 'e' (e.g. e00001)."),
  );
  $info['tokens']['node']['manuscript_id'] = array(
    'name' => t('Manuscript ID of article'),
    'description' => t('The identifier of an article as a string of 5 digits (e.g. 00001).'),
  );
  $info['tokens']['node']['impact'] = array(
    'name' => t('Impact statement'),
    'description' => t('Impact statement of article node.'),
  );
  $info['tokens']['node']['ancestor-title'] = array(
    'name' => t('Ancestor title'),
    'description' => t('Title of ancestor article node.'),
  );
  $info['tokens']['node']['canonical_url'] = array(
    'name' => t('Canonical URL'),
    'description' => t('URL to be used as canonical for article version, subarticles and fragments.'),
  );
  return $info;
}

/**
 * Implements hook_entity_property_info_alter().
 */
function elife_article_entity_property_info_alter(&$info) {
  $info['node']['bundles']['elife_contributor']['properties']['full_name'] = array(
    'type' => 'text',
    'label' => t('Name'),
    'sanitized' => TRUE,
    'getter callback' => 'elife_article_contributor_name',
  );
}

/**
 * Getter callback for elife_contributor full_name property.
 */
function elife_article_contributor_name($item) {
  return implode(' ', [
    $item->field_elife_a_fnames[LANGUAGE_NONE][0]['value'],
    $item->field_elife_a_surname[LANGUAGE_NONE][0]['value'],
  ]);
}

/**
 * Implements hook_tokens().
 */
function elife_article_tokens($type, $tokens, array $data = array(), array $options = array()) {
  $replacements = array();
  $sanitize = !empty($options['sanitize']);

  if ($type == 'node' && !empty($data['node'])) {
    $node = $data['node'];

    foreach ($tokens as $name => $original) {
      switch ($name) {
        case 'version_no':
          if ($dto = elife_article_version_to_dto($node)) {
            $version = $dto->getVersion();
          }
          else {
            $version = $original;
          }
          $replacements[$original] = $sanitize ? check_plain($version) : $version;
          break;

        case 'eloc_id':
          if ($dto = elife_article_version_to_dto($node)) {
            $eloc_id = $dto->getElocationId();
          }
          else {
            $eloc_id = $original;
          }
          $replacements[$original] = $sanitize ? check_plain($eloc_id) : $eloc_id;
          break;

        case 'manuscript_id':
          if ($dto = elife_article_version_to_dto($node)) {
            $manuscript_id = ltrim($dto->getElocationId(), 'e');
          }
          else {
            $manuscript_id = $original;
          }
          $replacements[$original] = $sanitize ? check_plain($manuscript_id) : $manuscript_id;
          break;

        case 'impact':
          if ($ewrapper = entity_metadata_wrapper('node', $node)) {
            if (in_array($ewrapper->getBundle(), [
              'elife_article_ver',
              'elife_fragment',
            ])) {
              if ($ewrapper->field_elife_a_parent->raw()) {
                $article_version = elife_article_version_to_dto($ewrapper->field_elife_a_parent->value());
              }
              else {
                $article_version = elife_article_version_to_dto($node);
              }

              $impact = $article_version->getImpactStatement();
              if (empty($impact)) {
                $markup = elife_article_markup_service();
                $markup->addDCDescriptionQuery($article_version->getArticleVersionId());
                $markup = _elife_article_markup_query($markup);
                $impact = $markup->output();
              }
              $replacements[$original] = $sanitize ? check_plain($impact) : $impact;
            }
          }
          break;

        case 'ancestor-title':
          if ($ewrapper = entity_metadata_wrapper('node', $node)) {
            if (in_array($ewrapper->getBundle(), [
              'elife_article_ver',
              'elife_fragment',
            ])) {
              if ($ewrapper->getBundle() == 'elife_fragment' && $ewrapper->field_elife_a_parent_sub->raw()) {
                $parent = $ewrapper->field_elife_a_parent_sub->value();
              }
              elseif ($ewrapper->field_elife_a_parent->raw()) {
                $parent = $ewrapper->field_elife_a_parent->value();
              }
              else {
                $parent = $node;
              }

              $ancestor_title = $parent->title;
              $replacements[$original] = $sanitize ? check_plain($ancestor_title) : $ancestor_title;
            }
          }
          break;

        case 'canonical_url':
          if (in_array($node->type, [
            'elife_article_ver',
            'elife_fragment',
          ])) {
            $url = drupal_get_path_alias('node/' . $node->nid);
            if (preg_match('/^(?P<canonical_url>content\/[0-9]+\/e[0-9]+)/', $url, $match)) {
              $canonical_url = url($match['canonical_url'], ['absolute' => TRUE]);
              $replacements[$original] = $sanitize ? check_plain($canonical_url) : $canonical_url;
            }
          }
      }
    }
  }

  return $replacements;
}

/**
 * Implements hook_tokens_alter().
 */
function elife_article_tokens_alter(array &$replacements, array $context) {
  if (
    'entity' === $context['type']
    &&
    'taxonomy_term' === $context['data']['entity_type']
    &&
    isset($context['data']['entity']->field_elife_category_plural)
    &&
    (
      empty($context['data']['entity']->field_elife_category_plural[LANGUAGE_NONE])
      ||
      '' === trim($context['data']['entity']->field_elife_category_plural[LANGUAGE_NONE][0]['value'])
    )
    &&
    isset($context['tokens']['field_elife_category_plural'])
  ) {
    $replacements[$context['tokens']['field_elife_category_plural']] = $context['data']['entity']->field_elife_title[LANGUAGE_NONE][0]['value'];
  }
}

/**
 * @return JsonSerializer
 */
function elife_article_serializer() {
  $jmsSerializer = &drupal_static(__FUNCTION__);

  if (!isset($jmsSerializer)) {
    AnnotationRegistry::registerAutoloadNamespace(
      'JMS\Serializer\Annotation',
      variable_get('elife_composer_vendor_path') . '/jms/serializer/src'
    );

    $jmsSerializer = JMS\Serializer\SerializerBuilder::create()
      ->configureHandlers(function (HandlerRegistry $registry) {
        $registry->registerSubscribingHandler(new ContributorHandler());
        $registry->registerSubscribingHandler(new FragmentHandler());
        $registry->registerSubscribingHandler(new DateHandler());
      })
      ->configureListeners(function (EventDispatcher $dispatcher) {
        $dispatcher->addSubscriber(new SubArticleSubscriber());
      })
      ->setCacheDir(variable_get('elife_cache_dir', sys_get_temp_dir()) . '/jms_serializer')
      ->setDebug(ELIFE_ENVIRONMENT_PRODUCTION !== elife_environment())
      ->build();
  }

  $serializationContext = SerializationContext::create()
    ->addExclusionStrategy(new DefaultValueExclusionStrategy());

  $deserializationContext = DeserializationContext::create();

  return new JMSJsonSerializer($jmsSerializer, $serializationContext, $deserializationContext);
}

/**
 * @return JsonValidator
 */
function elife_article_validator() {
  $validator = &drupal_static(__FUNCTION__);

  if (!isset($validator)) {
    $validator = new NodeJsonValidator(variable_get('elife_node_binary', 'node') . ' ' . DRUPAL_ROOT . '/' . libraries_get_path('elife-eif-schema') . '/validator.js');
  }

  return $validator;
}

/**
 * Get the path to the article version XML.
 *
 * @param string|object $article_version
 *   Article version id or article version node.
 *
 * @return bool|string
 *   Path to XML.
 */
function elife_article_version_source_xml_path($article_version) {
  if (!is_object($article_version)) {
    $article_version = ElifeArticleVersion::fromIdentifier($article_version, TRUE, 'elife_article_ver', 1, 'field_elife_a_article_version_id', TRUE);
  }

  $source_assets_base_path = variable_get('elife_article_source_assets_base_path');
  $source_xml_file_pattern = variable_get('elife_article_source_assets_xml_file_pattern');

  if (empty($source_assets_base_path) || empty($source_xml_file_pattern) || empty($article_version)) {
    return FALSE;
  }
  else {
    if (module_exists('token')) {
      $source_xml_file_pattern = token_replace($source_xml_file_pattern, array('node' => $article_version));
    }

    return $source_assets_base_path . $source_xml_file_pattern;
  }
}

/**
 * Get the path to the article version PDF.
 *
 * @param string|object $article_version
 *   Article version id or article version node.
 * @param bool $download
 *   Set to TRUE to request a file path prepared for download.
 *
 * @return bool|string
 *   Path to PDF.
 */
function elife_article_version_source_pdf_path($article_version, $download = FALSE) {
  if (!is_object($article_version)) {
    $article_version = ElifeArticleVersion::fromIdentifier($article_version);
  }

  $source_assets_base_path = variable_get('elife_article_source_assets_base_path');
  $source_pdf_file_pattern = variable_get('elife_article_source_assets_pdf_file_pattern');

  if (empty($source_assets_base_path) || empty($source_pdf_file_pattern)) {
    return FALSE;
  }
  else {
    if (module_exists('token')) {
      $source_pdf_file_pattern = token_replace($source_pdf_file_pattern, array('node' => $article_version));
    }

    if ($download) {
      $source_pdf_file_pattern = preg_replace('/(?!\-download)(.+)(\.pdf)$/', '$1-download$2', $source_pdf_file_pattern);
    }

    return $source_assets_base_path . $source_pdf_file_pattern;
  }
}

/**
 * Get the path to the article version figures PDF.
 *
 * @param string|object $article_version
 *   Article version id or article version node.
 * @param bool $download
 *   Set to TRUE to request a file path prepared for download.
 *
 * @return bool|string
 *   Path to figures PDF.
 */
function elife_article_version_source_figures_pdf_path($article_version, $download = FALSE) {
  if (!is_object($article_version)) {
    $article_version = ElifeArticleVersion::fromIdentifier($article_version);
  }

  $source_assets_base_path = variable_get('elife_article_source_assets_base_path');
  $source_figures_pdf_file_pattern = variable_get('elife_article_source_assets_figures_pdf_file_pattern');

  if (empty($source_assets_base_path) || empty($source_figures_pdf_file_pattern)) {
    return FALSE;
  }
  else {
    if (module_exists('token')) {
      $source_figures_pdf_file_pattern = token_replace($source_figures_pdf_file_pattern, array('node' => $article_version));
    }

    if ($download) {
      $source_figures_pdf_file_pattern = preg_replace('/(?!\-download)(.+)(\.pdf)$/', '$1-download$2', $source_figures_pdf_file_pattern);
    }

    return $source_assets_base_path . $source_figures_pdf_file_pattern;
  }
}

/**
 * Get the local path to the article version PDF.
 *
 * @param string|object $article_version
 *   Article version id or article version node.
 * @param bool $download
 *   Set to TRUE to request a file path prepared for download.
 *
 * @return bool|string
 *   Local path to PDF.
 */
function elife_article_version_source_pdf_local($article_version, $download = FALSE) {
  return url('node/' . $article_version->nid, ['absolute' => TRUE]) . (($download) ? '-download' : '') . '.pdf';
}

/**
 * Get the local path to the article version figures PDF.
 *
 * @param string|object $article_version
 *   Article version id or article version node.
 * @param bool $download
 *   Set to TRUE to request a file path prepared for download.
 *
 * @return bool|string
 *   Local path to PDF.
 */
function elife_article_version_source_figures_pdf_local($article_version, $download = FALSE) {
  return url('node/' . $article_version->nid, ['absolute' => TRUE]) . (($download) ? '-download' : '') . '.figures.pdf';
}

/**
 * @return ElifeMarkupService
 */
function elife_article_markup_service() {
  /* @var string $factory */
  $factory = variable_get('elife_article_markup_service_factory', '_elife_article_xsl_markup_service');
  $markup_service = $factory();
  return $markup_service;
}

/**
 * @return ElifeXslMarkupService
 */
function _elife_article_xsl_markup_service() {
  $markup_service = new ElifeXslMarkupService();
  return $markup_service;
}

/**
 * @return MockXslMarkupService
 */
function _elife_article_mock_xsl_markup_service() {
  $markup_service = new MockXslMarkupService();
  return $markup_service;
}

/**
 * @return MockMarkupService
 */
function _elife_article_mock_markup_service() {
  $markup_service = new MockMarkupService();
  return $markup_service;
}

/**
 * Get original article info for registered report or replication study.
 *
 * @param $article_version_id
 *   Article version id.
 *
 * @return array|null
 */
function elife_article_original_article($article_version_id) {
  $markup = elife_article_markup_service();
  $markup->addSectionQuery($article_version_id, 'original-article');
  $markup = _elife_article_markup_query($markup);
  $original_article = $markup->output();
  $values = array();
  foreach (explode("\n", $original_article) as $value) {
    if (preg_match('/^(?P<key>[A-z]+)=(?P<value>.*)$/', $value, $match)) {
      $values[$match['key']] = $match['value'];
    }
  }

  if (!empty($values)) {
    if (isset($values['author'])) {
      $values['author'] = explode('|', $values['author']);
    }

    return $values;
  }
}

/**
 * @return ElifeCitationService
 */
function elife_article_citation_service() {
  /* @var string $factory */
  $factory = variable_get('elife_article_citation_service_factory', '_elife_article_citation_service');
  $markup_service = $factory();
  return $markup_service;
}

/**
 * @return ElifeCitationService
 */
function _elife_article_citation_service() {
  $citation_service = new ElifeCitationService();
  return $citation_service;
}

/**
 * @return MockCitationService
 */
function _elife_article_mock_citation_service_disabled() {
  $citation_service = new MockCitationService();
  $citation_service->disableQuery();
  return $citation_service;
}

/**
 * @return MockCitationService
 */
function _elife_article_mock_citation_service() {
  $citation_service = new MockCitationService();
  return $citation_service;
}

function elife_article_version_to_dto(stdClass $entity, $flush = FALSE, $byPassCache = FALSE) {
  static $cache = [];

  if ($entity->type != 'elife_article_ver') {
    return FALSE;
  }

  /* @var EntityDrupalWrapper $ewrapper */
  $ewrapper = entity_metadata_wrapper('node', $entity);

  if ($ewrapper->field_elife_a_subarticle->value() == 1) {
    return FALSE;
  }

  if (isset($cache[$ewrapper->field_elife_a_article_version_id->value()])) {
    if(!$byPassCache) {
      return $cache[$ewrapper->field_elife_a_article_version_id->value()];
    }
  }

  if (!$flush && $eif_json = elife_services_eif_json($ewrapper->field_elife_a_article_version_id->value(), TRUE)) {
    $article_version = elife_article_serializer()->deserialize($eif_json);
  }
  else {
    $article_version = elife_article_version_to_dto_legacy($entity);
    // If we aren't storing the EIF Json yet, then store it.
    $data = elife_article_serializer()->serialize($article_version);
    $eif_json = json_decode($data);
    if (isset($eif_json->update)) {
      unset($eif_json->update);
    }
    unset($eif_json->publish);
    $data = json_encode($eif_json);
    elife_article_eif_json_store($entity->nid, $data);
    // Ensure we are storing the contributor names against the article version.
    $contributor_names = [];
    foreach ($article_version->getContributors() as $contributor) {
      if (!($contributor instanceof NonBylineContributor)) {
        $contributor_name = FALSE;
        if ($contributor instanceof Contributor) {
          if ($contributor instanceof BylineContributor) {
            $contributor_name = $contributor->getGivenNames() . ' ' . $contributor->getSurname();
          }
          elseif ($contributor instanceof CollabContributor) {
            $contributor_name = $contributor->getCollab();
          }
        }
        elseif ($contributor instanceof OnBehalfOfContributor) {
          $contributor_name = $contributor->getOnBehalfOf();
        }
        if ($contributor_name) {
          $contributor_names[] = ['value' => $contributor_name];
        }
      }
    }
    if (!empty($contributor_names)) {
      $node_field = new stdClass();
      $node_field->nid = $entity->nid;
      $node_field->type = 'elife_article_ver';
      $node_field->field_elife_a_contributor_names[LANGUAGE_NONE] = $contributor_names;
      field_attach_presave('node', $node_field);
      field_attach_update('node', $node_field);
    }
  }

  $cache[$ewrapper->field_elife_a_article_version_id->value()] = $article_version;

  return $article_version;
}

/**
 * @deprecated
 */
function elife_article_version_to_dto_legacy(stdClass $entity) {
  static $cache = [];

  if ($entity->type != 'elife_article_ver') {
    return FALSE;
  }

  /* @var EntityDrupalWrapper $entity */
  $entity = entity_metadata_wrapper('node', $entity);

  if ($entity->field_elife_a_subarticle->value() == 1) {
    return FALSE;
  }

  if (isset($cache[$entity->field_elife_a_article_version_id->value()])) {
    return $cache[$entity->field_elife_a_article_version_id->value()];
  }

  $entity_article = ElifeArticleVersion::getArticle($entity->field_elife_a_article_id->value(), TRUE, TRUE);
  /* @var EntityDrupalWrapper $entity_article */
  $entity_article = entity_metadata_wrapper('node', $entity_article);

  $categories = [];
  foreach ($entity->field_elife_a_category->value() as $entity_category) {
    /* @var EntityDrupalWrapper $entity_category */
    $entity_category = entity_metadata_wrapper('taxonomy_term', $entity_category);
    $categories[$entity_category->field_elife_category_type->value()][] = $entity_category->field_elife_title->value()['value'];
  }

  foreach ($entity->field_elife_a_heading->value() as $entity_heading) {
    /* @var EntityDrupalWrapper $entity_heading */
    $entity_heading = entity_metadata_wrapper('taxonomy_term', $entity_heading);
    $categories['heading'][] = $entity_heading->field_elife_title->value()['value'];
  }

  $keywords = [];
  foreach ($entity->field_elife_a_keyword->value() as $entity_keyword) {
    /* @var EntityDrupalWrapper $entity_keyword */
    $entity_keyword = entity_metadata_wrapper('taxonomy_term', $entity_keyword);
    $keywords[$entity_keyword->field_elife_a_kwd_type->value()][] = $entity_keyword->field_elife_title->value()['value'];
  }

  $related_articles = [];
  $related_query = db_select('elife_related_articles', 'era');
  $related_query->condition('era.source_doi', $entity->field_elife_a_doi->value());
  $related_query->fields('era');
  $related_results = $related_query->execute();
  foreach ($related_results as $related_result) {
    $related_articles[] = new RelatedArticle($related_result->description, $related_result->dest_doi);
  }

  $referenced = [
    'equal-contrib' => [],
    'email' => [],
    'funding' => [],
    'competing-interest' => [],
    'contribution' => [],
    'present-address' => [],
    'affiliation' => [],
    'related-object' => [],
    'foot-note' => [],
  ];

  foreach ($entity->field_elife_a_basic_ref->value() as $entity_basic_ref) {
    /* @var EntityDrupalWrapper $entity_basic_ref */
    $entity_basic_ref = entity_metadata_wrapper('field_collection_item', $entity_basic_ref);

    $referenced[$entity_basic_ref->field_elife_a_basic_ref_type->value()][$entity_basic_ref->field_elife_a_ref_key->value()] = $entity_basic_ref->field_elife_a_basic_ref_value->value();
  }

  foreach ($entity->field_elife_a_fund_ref->value() as $entity_fund_ref) {
    /* @var EntityDrupalWrapper $entity_fund_ref */
    $entity_fund_ref = entity_metadata_wrapper('field_collection_item', $entity_fund_ref);

    $referenced['funding'][$entity_fund_ref->field_elife_a_ref_key->value()] = new Funding(
      $entity_fund_ref->field_elife_a_fund_ref_id->value(),
      $entity_fund_ref->field_elife_a_fund_ref_id_type->value(),
      $entity_fund_ref->field_elife_a_fund_ref_inst->value(),
      'university',
      $entity_fund_ref->field_elife_a_fund_ref_award_id->value()
    );
  }

  foreach ($entity->field_elife_a_aff_ref->value() as $entity_aff_ref) {
    /* @var EntityDrupalWrapper $entity_aff_ref */
    $entity_aff_ref = entity_metadata_wrapper('field_collection_item', $entity_aff_ref);

    $referenced['affiliation'][$entity_aff_ref->field_elife_a_ref_key->value()] = new Affiliation(
      $entity_aff_ref->field_elife_a_aff_ref_dept->value(),
      $entity_aff_ref->field_elife_a_aff_ref_inst->value(),
      $entity_aff_ref->field_elife_a_aff_ref_city->value(),
      $entity_aff_ref->field_elife_a_aff_ref_country->value(),
      $entity_aff_ref->field_elife_a_aff_ref_email->value()
    );
  }

  foreach ($entity->field_elife_a_rel_ref->value() as $entity_rel_ref) {
    /* @var EntityDrupalWrapper $entity_rel_ref */
    $entity_rel_ref = entity_metadata_wrapper('field_collection_item', $entity_rel_ref);

    $referenced['related-object'][$entity_rel_ref->field_elife_a_ref_key->value()] = new RelatedObject();
  }

  foreach ($entity->field_elife_a_fn_ref->value() as $entity_fn_ref) {
    /* @var EntityDrupalWrapper $entity_fn_ref */
    $entity_fn_ref = entity_metadata_wrapper('field_collection_item', $entity_fn_ref);

    $referenced['foot-note'][$entity_fn_ref->field_elife_a_ref_key->value()] = new FootNote(
      $entity_fn_ref->field_elife_a_fn_ref_type->value(),
      $entity_fn_ref->field_elife_a_fn_ref_value->value()
    );
  }

  $referenced = new Referenced(
    $referenced['equal-contrib'],
    $referenced['email'],
    $referenced['funding'],
    $referenced['competing-interest'],
    $referenced['contribution'],
    $referenced['present-address'],
    $referenced['affiliation'],
    $referenced['related-object'],
    $referenced['foot-note']
  );

  $get_fragments = function ($entity) use (&$get_fragments) {
    $fragments = [];
    /* @var EntityDrupalWrapper $entity_fragment */
    foreach ($entity->field_elife_a_fragments as $entity_fragment) {
      if ('elife_article_ver' === $entity_fragment->getBundle()) {
        $contributors = [];
        foreach ($entity_fragment->field_elife_a_contributors_pri->value() as $entity_contributor) {
          /* @var EntityDrupalWrapper $entity_contributor */
          $entity_contributor = entity_metadata_wrapper('node', $entity_contributor);

          $references = [];

          $references_map = [
            'equal-contrib' => 'field_elife_a_basic_ref_links',
            'email' => 'field_elife_a_basic_ref_links',
            'funding' => 'field_elife_a_fund_ref_links',
            'competing-interest' => 'field_elife_a_basic_ref_links',
            'contribution' => 'field_elife_a_basic_ref_links',
            'present-address' => 'field_elife_a_basic_ref_links',
            'affiliation' => 'field_elife_a_aff_ref_links',
            'related-object' => 'field_elife_a_rel_ref_links',
            'foot-note' => 'field_elife_a_fn_ref_links',
          ];

          foreach ($references_map as $type => $field) {
            foreach ($entity_contributor->$field->value() as $entity_contributor_reference) {
              /* @var EntityDrupalWrapper $entity_contributor_reference */
              $entity_contributor_reference = entity_metadata_wrapper('field_collection_item', $entity_contributor_reference);
              if ('field_elife_a_basic_ref_links' === $field) {
                if ($type !== $entity_contributor_reference->field_elife_a_basic_ref_type->value()) {
                  continue;
                }
              }
              $references[$type][] = $entity_contributor_reference->field_elife_a_ref_key->value();
            }
          }

          $affiliations = [];
          if (
            $entity_contributor->field_elife_a_aff_dept->value() ||
            $entity_contributor->field_elife_a_aff_inst->value() ||
            $entity_contributor->field_elife_a_aff_city->value() ||
            $entity_contributor->field_elife_a_aff_country->value() ||
            $entity_contributor->field_elife_a_aff_email->value()
          ) {
            $affiliations[] = new Affiliation(
              $entity_contributor->field_elife_a_aff_dept->value(),
              $entity_contributor->field_elife_a_aff_inst->value(),
              $entity_contributor->field_elife_a_aff_city->value(),
              $entity_contributor->field_elife_a_aff_country->value(),
              $entity_contributor->field_elife_a_aff_email->value()
            );
          }

          if ($entity_contributor->field_elife_a_collab->value()) {
            $contributors[] = new CollabContributor(
              $entity_contributor->field_elife_a_contrib_type->value(),
              $entity_contributor->field_elife_a_corresp->value(),
              $entity_contributor->field_elife_a_author_id->value(),
              $entity_contributor->field_elife_a_group_author_key->value(),
              $references,
              $entity_contributor->field_elife_a_collab->value(),
              $affiliations
            );
          }
          else {
            $contributors[] = new BylineContributor(
              $entity_contributor->field_elife_a_contrib_type->value(),
              $entity_contributor->field_elife_a_corresp->value(),
              $entity_contributor->field_elife_a_author_id->value(),
              $entity_contributor->field_elife_a_group_author_key->value(),
              $references,
              $entity_contributor->field_elife_a_equal_contrib->value(),
              $entity_contributor->field_elife_a_deceased->value(),
              $entity_contributor->field_elife_a_surname->value(),
              $entity_contributor->field_elife_a_fnames->value(),
              $entity_contributor->field_elife_a_author_suffix->value(),
              $entity_contributor->field_elife_a_email->value(),
              $entity_contributor->field_elife_a_orcid_id->value(),
              $entity_contributor->field_elife_a_author_role->value(),
              $affiliations
            );
          }
        }

        $fragments[] = new SubArticle(
          $entity_fragment->field_elife_title->value()['value'],
          $entity_fragment->field_elife_a_doi->value(),
          drupal_get_path_alias('node/' . $entity_fragment->getIdentifier()),
          $get_fragments($entity_fragment),
          $contributors
        );
      }
      else {
        $fragments[] = new Fragment(
          $entity_fragment->field_elife_a_frag_type->value(),
          $entity_fragment->field_elife_title->value()['value'],
          $entity_fragment->field_elife_a_doi->value(),
          drupal_get_path_alias('node/' . $entity_fragment->getIdentifier()),
          $get_fragments($entity_fragment)
        );
      }
    }
    return $fragments;
  };

  $fragments = $get_fragments($entity);

  $contributors = [];
  $citations = [];

  $parts = [];
  if ($contributors_json = $entity->field_elife_a_contributors_json->value()) {
    $parts[] = '"contributors":' . $contributors_json;
  }
  if ($citations_json = $entity->field_elife_a_citations_json->value()) {
    $parts[] = '"citations":' . $citations_json;
  }

  if (!empty($parts)) {
    $parts = elife_article_serializer()->deserialize('{' . implode(',', $parts) . '}');
    if ($contributors_json) {
      $contributors = $parts->getContributors();
    }
    if ($citations_json) {
      $citations = $parts->getCitations();
    }
  }

  if ($entity->field_elife_a_author_imp->value()) {
    $impact_statement = $entity->field_elife_a_author_imp->value()['value'];
  }
  else {
    $impact_statement = NULL;
  }

  if ($entity_article->field_elife_a_fpubdate->value()) {
    $pub_date = DateTimeImmutable::createFromFormat('U', $entity_article->field_elife_a_fpubdate->value());
  }
  else {
    $pub_date = NULL;
  }

  if ($entity->field_elife_a_update->value()) {
    $update = DateTimeImmutable::createFromFormat('U', $entity->field_elife_a_update->value());
  }
  else {
    $update = NULL;
  }

  $article_version = new ArticleVersion(
    $entity->field_elife_title->value()['value'],
    $impact_statement,
    $entity->field_elife_a_version->value(),
    $entity->field_elife_a_doi->value(),
    $entity->status->value(),
    $entity_article->field_elife_a_volume->value(),
    $entity->field_elife_a_elocation_id->value(),
    $entity->field_elife_a_article_id->value(),
    $entity->field_elife_a_article_version_id->value(),
    $pub_date,
    $update,
    drupal_get_path_alias('node/' . $entity->getIdentifier()),
    $entity->field_elife_a_article_type->value(),
    $entity->field_elife_a_status->value(),
    $categories,
    $keywords,
    $related_articles,
    $contributors,
    $referenced,
    $fragments,
    $citations
  );

  $cache[$entity->field_elife_a_article_version_id->value()] = $article_version;

  return $article_version;
}

function elife_article_from_dto(ArticleVersion $article_version, $uid) {
  $entity = ElifeArticleVersion::getArticle($article_version->getArticleId());

  // Only update title and related articles if this version is latest.
  $versions = ElifeArticleVersion::fromId($article_version->getArticleId(), FALSE);
  $latest_status = '';
  $latest_version = 0;
  if (!empty($versions)) {
    $latest = reset($versions);
    $latest_status = $latest->extraFields->field_elife_a_status_status;
    $latest_version = $latest->extraFields->field_elife_a_version_version;
  }

  // @todo - elife - nlisgo - we may wish to only overwrite these values only when a version is the latest and published.
  // We would need to store all of these values against the version in that
  // refactor.

  $pub_date = $article_version->getPubDate();

  // It this is the latest version of an article then delete the entity so we
  // can cleanly load in the latest values.
  if ($entity && (
      $latest_version === 0
      // Check to see if incoming status is VOR and we only have POA stored.
      || strcasecmp($article_version->getStatus(), $latest_status) > 0
      || $article_version->getVersion() >= $latest_version)
  ) {
    // Preserve pub-date in case it is not supplied with more recent version.
    if (!$pub_date) {
      /* @var EntityDrupalWrapper $ewrapper */
      $ewrapper = entity_metadata_wrapper('node', $entity);

      if ($ewrapper->field_elife_a_fpubdate->value()) {
        $pub_date = DateTimeImmutable::createFromFormat('U', $ewrapper->field_elife_a_fpubdate->value());
      }
      else {
        $pub_date = NULL;
      }
      unset($ewrapper);
    }
    entity_delete('node', $entity->nid);
    $entity = NULL;
  }

  if (!$entity) {
    $entity = entity_create('node', [
      'type' => 'elife_article',
      'uid' => $uid,
    ]);
    $new = TRUE;
  }
  else {
    $new = FALSE;
  }

  /* @var EntityDrupalWrapper $entity */
  $entity = entity_metadata_wrapper('node', $entity);

  // Amending the versions of an article can happen each time a new version is
  // processed.
  elife_article_versions_array($article_version->getArticleVersionId());

  $entity->field_elife_a_versions->set(array_values($versions));

  if ($new) {
    $entity->raw()->status = (int) $article_version->getPublish();
    $entity->field_elife_title->set([
      'value' => $article_version->getTitle(),
      'format' => 'elife_house_style',
    ]);
    $entity->field_elife_a_volume->set($article_version->getVolume());
    $entity->field_elife_a_article_id->set($article_version->getArticleId());
    if ($pub_date instanceof DateTimeImmutable) {
      $entity->field_elife_a_fpubdate->set($pub_date
        ->getTimestamp());
    }
    elseif ($article_version->getPublish() && !$entity->field_elife_a_fpubdate->value()) {
      // @todo - elife - nlisgo - I would prefer to do this as a rule.
      $entity->field_elife_a_fpubdate->set(time());
    }
    elseif (!$entity->field_elife_a_fpubdate->value()) {
      $entity->field_elife_a_fpubdate->set(NULL);
    }

    $entity->save();

    db_delete('elife_related_articles')
      ->condition('source_doi', $article_version->getDoi())
      ->execute();

    foreach ($article_version->getRelatedArticles() as $related_article) {
      db_merge('elife_related_articles')
        ->key([
          'source_doi' => $article_version->getDoi(),
          'dest_doi' => $related_article->getHref(),
        ])
        ->fields([
          'description' => $related_article->getType(),
        ])
        ->execute();
    }
  }

  $entity->save();

  return $entity->raw();
}

/**
 * Get an array of versions with the corresponding nids in descending order.
 *
 * @param $article_id
 * @param bool|FALSE $most_recent
 * @return array
 * @throws \EntityFieldQueryException
 */
function elife_article_versions_array($article_id, &$most_recent = FALSE) {
  $versions = [];
  $query = new EntityFieldQueryExtraFields();
  $query->addTag('DANGEROUS_ACCESS_CHECK_OPT_OUT');
  $query->entityCondition('entity_type', 'node');
  $query->entityCondition('bundle', 'elife_article_ver');
  $query->fieldCondition('field_elife_a_article_id', 'value', $article_id);
  $query->addExtraField('field_elife_a_version', 'value', 'version');
  $query->addExtraField('', 'status', 'status', 'node');
  $query->propertyOrderBy('status', 'DESC');
  $query->fieldOrderBy('field_elife_a_version', 'value', 'DESC');
  $most_recent = FALSE;

  if ($result = $query->execute()) {
    if (isset($result['node']) && !empty($result['node'])) {
      foreach ($result['node'] as $nid => $version) {
        if (!empty($version->extraFields->field_elife_a_version_version)) {
          $versions[$version->extraFields->field_elife_a_version_version] = $nid;
          $most_recent = (!$most_recent && $version->extraFields->status == 1) ? $version->extraFields->field_elife_a_version_version : $most_recent;
        }
      }
    }
  }

  return $versions;
}

/**
 * Ensure that the url paths for the article version content are as expected.
 *
 * @param ArticleVersion $dto
 */
function elife_article_version_paths_resolve(ArticleVersion $dto) {
  $most_recent = FALSE;
  $versions = elife_article_versions_array($dto->getArticleId(), $most_recent);
  $versions = array_reverse($versions, TRUE);
  foreach ($versions as $version => $nid) {
    $query = db_select('url_alias', 'ua');
    $query->innerJoin('url_alias', 'ua2', 'SUBSTRING(ua2.alias, 1, LENGTH(ua.alias)) = ua.alias');
    $query->addField('ua2', 'pid', 'alias_pid');
    $query->addField('ua2', 'alias', 'old_alias');
    $query->addField('ua2', 'source');
    $query->condition('ua.source', 'node/' . $nid);
    if ($version == $most_recent) {
      $query->condition('ua.alias', '^content/[0-9]+/e[0-9]{5}v[0-9]+$', 'REGEXP');
      $query->condition('ua2.alias', '^content/[0-9]+/e[0-9]{5}(/.+)?$', 'NOT REGEXP');
    }
    else {
      $query->condition('ua.alias', '^content/[0-9]+/e[0-9]{5}$', 'REGEXP');
      $query->condition('ua2.alias', '^content/[0-9]+/e[0-9]{5}v[0-9]+(/.+)?$', 'NOT REGEXP');
    }
    $query->orderBy('ua2.alias');
    if ($results = $query->execute()->fetchAllAssoc('source')) {
      foreach ($results as $source => $result) {
        if ($path = path_load(['source' => $source])) {
          if ($version == $most_recent) {
            $new_path = preg_replace('/^(content\/[0-9]\/e[0-9]{5})v[0-9]+(.*)$/', '$1$2', $path['alias']);
          }
          else {
            $new_path = preg_replace('/^(content\/[0-9]\/e[0-9]{5})(\/?.*)$/', '$1v' . $version . '$2', $path['alias']);
          }
          if ($new_path) {
            path_delete(['pid' => $path['pid']]);
            unset($path['pid']);
            $path['alias'] = $new_path;
            path_save($path);
          }
        }
      }
    }
  }
}

function elife_article_version_from_dto(ArticleVersion $article_version, $uid) {
  $entity = entity_create('node', [
    'type' => 'elife_article_ver',
    'uid' => $uid,
  ]);

  /* @var EntityDrupalWrapper $entity */
  $entity = entity_metadata_wrapper('node', $entity);

  $entity->title->set($article_version->getTitle());
  $entity->field_elife_title->set([
    'value' => $article_version->getTitle(),
    'format' => 'elife_house_style',
  ]);
  if ($article_version->getImpactStatement()) {
    $entity->field_elife_a_author_imp->set([
      'value' => $article_version->getImpactStatement(),
      'format' => 'elife_house_style',
    ]);
  }
  $entity->field_elife_a_version->set($article_version->getVersion());
  $entity->field_elife_a_doi->set($article_version->getDoi());
  $entity->status->set((int) $article_version->getPublish());
  $entity->field_elife_a_article_id->set($article_version->getArticleId());
  $entity->field_elife_a_elocation_id->set($article_version->getElocationId());
  $entity->field_elife_a_article_version_id->set($article_version->getArticleVersionId());
  if ($article_version->getUpdate()) {
    $entity->field_elife_a_update->set($article_version->getUpdate()
      ->getTimestamp());
  }
  else {
    $entity->field_elife_a_update->set(NULL);
  }
  $entity->field_elife_a_article_type->set($article_version->getArticleType());
  $entity->field_elife_a_status->set($article_version->getStatus());

  $entity_categories = [];
  $entity_headings = [];
  foreach ($article_version->getCategories() as $group => $categories) {
    if ('heading' === $group) {
      foreach ($categories as $category) {
        if ($term = _elife_services_article_prepare_term('elife_headings', $category)) {
          $entity_headings[] = $term->tid;
        }
      }
    }
    else {
      foreach ($categories as $category) {
        $category_fields = [
          'field_elife_category_type' => $group,
        ];
        if ($term = _elife_services_article_prepare_term('elife_categories', $category, [], $category_fields)) {
          $entity_categories[] = $term->tid;
        }
      }
    }
  }
  $entity->field_elife_a_category->set($entity_categories);
  $entity->field_elife_a_heading->set($entity_headings);

  $entity_keywords = [];
  foreach ($article_version->getKeywords() as $group => $keywords) {
    foreach ($keywords as $keyword) {
      $keyword_fields = [
        'field_elife_title' => [
          'value' => $keyword,
          'format' => 'elife_house_style',
        ],
        'field_elife_a_kwd_type' => $group,
      ];
      if ($term = _elife_services_article_prepare_term('elife_keywords', $keyword, [], $keyword_fields)) {
        $entity_keywords[] = $term->tid;
      }
    }
  }
  $entity->field_elife_a_keyword->set($entity_keywords);

  $entity->save();

  // Add or amend the content alias.
  $source = 'node/' . $entity->nid->value();
  // Check to see that path is unique.
  if (!$path = path_load(array('alias' => $article_version->getPath()))) {
    _elife_article_create_path($article_version->getPath(), $source);
  }

  $referenced = $article_version->getReferenced();
  $entity->field_elife_a_emails->set(array_values($referenced->getEmail()));

  $contributor_names = [];
  foreach ($article_version->getContributors() as $contributor) {
    if (!($contributor instanceof NonBylineContributor)) {
      if ($contributor instanceof Contributor) {
        if ($contributor instanceof BylineContributor) {
          $contributor_names[] = $contributor->getGivenNames() . ' ' . $contributor->getSurname();
        }
        elseif ($contributor instanceof CollabContributor) {
          $contributor_names[] = $contributor->getCollab();
        }
      }
      elseif ($contributor instanceof OnBehalfOfContributor) {
        $contributor_names[] = $contributor->getOnBehalfOf();
      }
    }
  }

  if (!empty($contributor_names)) {
    $entity->field_elife_a_contributor_names->set($contributor_names);
  }

  $handle_fragments = function ($parent_id, array $fragments, $sub_article = FALSE) use ($uid, &$handle_fragments) {
    $entity_fragments = [];

    foreach ($fragments as $fragment) {
      if ($fragment instanceof SubArticle) {
        $entity_fragment = entity_create('node', [
          'type' => 'elife_article_ver',
          'uid' => $uid,
        ]);

        /* @var EntityDrupalWrapper $entity_fragment */
        $entity_fragment = entity_metadata_wrapper('node', $entity_fragment);

        $entity_fragment->field_elife_a_subarticle->set(TRUE);

        $entity_fragment->field_elife_a_parent->set($parent_id);
        $entity_fragment->save();
        $sub_article = $entity_fragment->getIdentifier();
      }
      else {
        /* @var Fragment $fragment */
        $values = [
          'type' => 'elife_fragment',
          'uid' => $uid,
        ];

        $entity_fragment = entity_create('node', $values);

        /* @var EntityDrupalWrapper $entity_fragment */
        $entity_fragment = entity_metadata_wrapper('node', $entity_fragment);

        $entity_fragment->field_elife_a_frag_type->set($fragment->getType());
        $entity_fragment->field_elife_a_subarticle->set(!empty($sub_article));
        if (!empty($sub_article)) {
          $entity_fragment->field_elife_a_parent_sub->set($sub_article);
        }

        $entity_fragment->field_elife_a_parent->set($parent_id);
        $entity_fragment->save();
      }

      $entity_fragment->title->set($fragment->getTitle());
      $entity_fragment->field_elife_title->set([
        'value' => $fragment->getTitle(),
        'format' => 'elife_house_style',
      ]);

      $entity_fragment->field_elife_a_doi->set($fragment->getDoi());

      $entity_fragment->field_elife_title->set([
        'value' => $fragment->getTitle(),
        'format' => 'elife_house_style',
      ]);
      $entity_fragment->field_elife_a_doi->set($fragment->getDoi());

      // Add or amend the content alias.
      $source = 'node/' . $entity_fragment->nid->value();
      // Check to see that path is unique.
      if (!$path = path_load(array('alias' => $fragment->getPath()))) {
        _elife_article_create_path($fragment->getPath(), $source);
      }

      $entity_fragment->field_elife_a_fragments->set($handle_fragments($parent_id, $fragment->getFragments(), $sub_article));

      $entity_fragment->save();

      $entity_fragments[] = $entity_fragment->getIdentifier();
    }

    return $entity_fragments;
  };

  $entity->field_elife_a_fragments->set($handle_fragments($entity->getIdentifier(), $article_version->getFragments()));

  $entity->save();

  return $entity->raw();
}

/**
 * Create a path alias.
 *
 * @param string $path
 *   Path alias.
 * @param string $source
 *   Source value (e.g. node/1234).
 */
function _elife_article_create_path($path, $source) {
  $content_path = array(
    'alias' => $path,
    'source' => $source,
  );

  $existing = path_load(array('source' => $source));

  if ($existing) {
    $content_path += $existing;
  }

  path_save($content_path);
}

/**
 * Implements hook_libraries_info().
 */
function elife_article_libraries_info() {
  $libraries['BetterDOMDocument'] = array(
    'name' => 'BetterDOMDocument',
    'version' => '1',
    'vendor url' => 'https://github.com/highwire/opensource-php-BetterDOMDocument',
    'download url' => 'https://raw.githubusercontent.com/highwire/opensource-php-BetterDOMDocument/master/BetterDOMDocument.php',
    'files' => array(
      'php' => array('BetterDOMDocument.php'),
    ),
  );

  return $libraries;
}

/**
 * Convert string which may contain xml to html.
 *
 * @param string $string
 *   String to convert.
 *
 * @return string
 *   String with xml converted to html.
 */
function _elife_article_xmltohtml($string) {
  if (($library = libraries_load('BetterDOMDocument')) && !empty($library['loaded'])) {
    $string = '<xmltohtml>' . $string . '</xmltohtml>';
    $dom = new BetterDOMDocument($string);
    $html = preg_replace('#^<span class="xmltohtml">(.*?)</span>$#is', '$1', $dom->asHTML());
    return $html;
  }
  else {
    return $string;
  }
}

/**
 * Prepare display channel links.
 *
 * @param ArticleVersion $article_version
 *   Article Object.
 * @param array $options
 *   Default options.
 *
 * @return array
 *   Array of display channel links
 */
function _elife_article_display_channel_links(ArticleVersion $article_version, $options = []) {
  $items = [];
  $display_channels = $article_version->getDisplayChannels();
  if (!empty($display_channels)) {
    $options += [
      'html' => TRUE,
      'attributes' => [
        'class' => [
          'category-display-channel',
          strtolower(preg_replace('/[^a-zA-Z0-9-]+/', '-', $display_channels[0])),
        ],
      ],
    ];
    $query = new EntityFieldQuery();
    $query->entityCondition('entity_type', 'taxonomy_term');
    $query->entityCondition('bundle', 'elife_categories');
    $query->fieldCondition('field_elife_category_type', 'value', 'display-channel');
    $query->fieldCondition('field_elife_title', 'value', $article_version->getDisplayChannels(), 'IN');
    if ($result = $query->execute()) {
      if (isset($result['taxonomy_term']) && !empty($result['taxonomy_term'])) {
        foreach ($result['taxonomy_term'] as $tid => $term) {
          $term = taxonomy_term_load($tid);
          // @todo - elife - nlisgo - add class for specific display channel
          $items[] = l($term->field_elife_title[LANGUAGE_NONE][0]['safe_value'], 'taxonomy/term/' . $tid, $options);
        }
      }
    }
  }
  return $items;
}

/**
 * Prepare heading links.
 *
 * @param ArticleVersion $article_version
 *   Article Object.
 * @param array $options
 *   Default options.
 *
 * @return array
 *   Array of heading links
 */
function _elife_article_heading_links(ArticleVersion $article_version, $options = []) {
  $items = [];
  if (!empty($article_version->getHeadings())) {
    $options += [
      'html' => TRUE,
      'attributes' => [
        'class' => [
          'category-heading',
        ],
      ],
    ];
    $query = new EntityFieldQuery();
    $query->entityCondition('entity_type', 'taxonomy_term');
    $query->entityCondition('bundle', 'elife_headings');
    $query->fieldCondition('field_elife_title', 'value', $article_version->getHeadings(), 'IN');
    if ($result = $query->execute()) {
      if (isset($result['taxonomy_term']) && !empty($result['taxonomy_term'])) {
        foreach ($result['taxonomy_term'] as $tid => $term) {
          $term = taxonomy_term_load($tid);
          $items[] = l($term->field_elife_title[LANGUAGE_NONE][0]['safe_value'], 'taxonomy/term/' . $tid, $options);
        }
      }
    }
  }
  return $items;
}

/**
 * Prepare keyword links.
 *
 * @param ArticleVersion $article_version
 *   Article Object.
 *
 * @return array
 *   Array of keyword links
 */
function _elife_article_keyword_links(ArticleVersion $article_version, $excludes = [
  'Other',
  'None',
]) {
  $items = [];
  $keyword_groups = $article_version->getKeywords();
  if (!empty($keyword_groups)) {
    $keywords = [];
    foreach ($keyword_groups as $group => $group_keywords) {
      foreach ($group_keywords as $group_keyword) {
        if (!in_array($group_keyword, $excludes)) {
          $keywords[] = $group_keyword;
        }
      }
    }
    if (!empty($keywords)) {
      $query = new EntityFieldQuery();
      $query->entityCondition('entity_type', 'taxonomy_term');
      $query->entityCondition('bundle', 'elife_keywords');
      $query->fieldCondition('field_elife_title', 'value', $keywords, 'IN');
      if ($result = $query->execute()) {
        if (!empty($result['taxonomy_term'])) {
          foreach ($result['taxonomy_term'] as $tid => $term) {
            $term = taxonomy_term_load($tid);
            $items[] = l($term->field_elife_title[LANGUAGE_NONE][0]['safe_value'], 'taxonomy/term/' . $tid, [
              'html' => TRUE,
              'attributes' => ['class' => ['keyword']],
            ]);
          }
        }
      }
    }
  }
  return $items;
}

/**
 * Implements hook_cron().
 */
function elife_article_cron() {
  // Populate empty main text fields for elife_article_ver nodes.
  $emptys = _elife_article_prepare_main_text(variable_get('elife_markup_pre_cron', 100));

  foreach (array_values($emptys) as $article_version_id) {
    // Warm the markup query cache for this article version.
    _elife_article_markup_cache_warm($article_version_id);
    // Warm the citation query cache at the same time.
    _elife_article_citation_cache_warm($article_version_id);
  }
}

/**
 * Prepare and populate all empty main text fields.
 *
 * @param int $limit
 *   Number to limit to.
 *
 * @return array
 *   Array of empty article versions that were populated.
 */
function _elife_article_prepare_main_text($limit = NULL) {
  $emptys = _elife_article_empty_main_text();
  if (NULL !== $limit) {
    $emptys = array_slice($emptys, 0, $limit, TRUE);
  }
  _elife_article_emptys_markup_populate($emptys);

  return $emptys;
}

/**
 * Grab the markup where needed and store in cache tables.
 *
 * @param array $emptys
 *   Array of empty article versions to be populated.
 */
function _elife_article_emptys_markup_populate($emptys) {
  $markup = _elife_article_emptys_markup($emptys);
  _elife_article_emptys_populate($markup);
}

/**
 * Store EIF Json string as a field in the elife_article_ver node.
 *
 * @param int $nid
 * @param string $data
 * @param bool $normalise
 */
function elife_article_eif_json_store($nid, $data, $normalise = TRUE) {
  if ($normalise) {
    $data = _elife_services_data_normalise($data);
  }

  $node_field = new stdClass();
  $node_field->nid = $nid;
  $node_field->type = 'elife_article_ver';
  $node_field->field_elife_a_eif_json[LANGUAGE_NONE][0]['value'] = $data;
  field_attach_presave('node', $node_field);
  field_attach_update('node', $node_field);
}

/**
 * Store updated date as a field in the elife_article_ver node.
 *
 * @param int $nid
 * @param string $unixdate
 */
function elife_article_update_store($nid, $unixdate) {
  $node_field = new stdClass();
  $node_field->nid = $nid;
  $node_field->type = 'elife_article_ver';
  $node_field->field_elife_a_update[LANGUAGE_NONE][0]['value'] = date('Y-m-d H:i:s', $unixdate);
  field_attach_presave('node', $node_field);
  field_attach_update('node', $node_field);
}

/**
 * Empty markup fields for existing article.
 *
 * @param int $nid
 */
function elife_article_empty_markup_fields($nid) {
  $node_field = new stdClass();
  $node_field->nid = $nid;
  $node_field->type = 'elife_article_ver';
  $node_field->field_elife_a_abstract = NULL;
  $node_field->field_elife_a_main_text = NULL;
  field_attach_presave('node', $node_field);
  field_attach_update('node', $node_field);
}

/**
 * Amend the nodes with the supplied markup in the main text field.
 *
 * @param array $populates
 *   Array of field=>value pairs with nid as key.
 *
 * @throws EntityMetadataWrapperException
 */
function _elife_article_emptys_populate($populates) {
  if (!empty($populates)) {
    $nodes = node_load_multiple(array_keys($populates));
    foreach ($nodes as $nid => $node) {
      /* @var EntityDrupalWrapper $ewrapper */
      $ewrapper = entity_metadata_wrapper('node', $node);
      foreach ($populates[$nid] as $field => $value) {
        if ('field_elife_a_abstract' === $field) {
          $value = ['value' => $value, 'format' => 'elife_full_html'];
        }
        $ewrapper->{$field}->set($value);
      }
      $ewrapper->save();
    }
  }
}

/**
 * Get the markup for the supplied articles to populate into main text field.
 *
 * @param array $emptys
 *   Array of article version ids.
 *
 * @return array
 *   Array of html with nid as key.
 */
function _elife_article_emptys_markup($emptys) {
  $markup = elife_article_markup_service();
  // Sections that we wish to include in fields.
  $sections = [
    'abstract' => 'field_elife_a_abstract',
    'main-text' => 'field_elife_a_main_text',
  ];
  foreach ($emptys as $key => $article_version_id) {
    foreach ($sections as $section => $field) {
      $markup->addSectionQuery($article_version_id, $section);
    }
  }
  $markup = _elife_article_markup_query($markup, FALSE);

  $populates = [];
  if ($results = $markup->getResults()) {
    foreach ($emptys as $nid => $empty) {
      if (isset($results[$empty])) {
        $populates[$nid] = [];
        foreach ($results[$empty] as $key => $result) {
          $populates[$nid][$sections[$key]] = implode('', $result);
        }
      }
    }
  }

  return $populates;
}

/**
 * Process article version id or article id to just retrieve e-location id.
 *
 * Once the article xml is retrievable in the correct location we can in most
 * cases we can stop using this function.
 *
 * @todo - elife - nlisgo - verify that uses of this function are still needed.
 *
 * @param string $article_id
 *   Article ID or Article Version ID
 *
 * @return string|NULL
 *   The e-location id if it can be derived from the ID given.
 */
function _elife_article_process_article_id($article_id) {
  if (preg_match('/[^0-9]*(?<id>[0-9]{5})[^0-9]*/', $article_id, $matches)) {
    return $matches['id'];
  }
}

/**
 * Retrieve the article version ids for all article versions with no main text.
 *
 * @param bool $force_empty
 *   If you want to consider all article versions as being empty set to FALSE.
 *
 * @return array
 *   Array of article version ids with the nid as a key.
 */
function _elife_article_empty_main_text($force_empty = FALSE) {
  $emptys = [];
  $query = new EntityFieldQueryExtraFields();
  $query->addTag('DANGEROUS_ACCESS_CHECK_OPT_OUT');
  if (!$force_empty) {
    $query->addTag('main_text_null');
  }
  $query->entityCondition('entity_type', 'node');
  $query->entityCondition('bundle', 'elife_article_ver');
  $results = $query->execute();
  if (!empty($results) && !empty($results['node'])) {
    $nids = array_keys($results['node']);
    $query = new EntityFieldQueryExtraFields();
    $query->addTag('DANGEROUS_ACCESS_CHECK_OPT_OUT');
    $query->entityCondition('entity_type', 'node');
    $query->entityCondition('bundle', 'elife_article_ver');
    $query->propertyCondition('nid', $nids, 'IN');
    $query->fieldCondition('field_elife_a_subarticle', 'value', 0);
    $query->addExtraField('field_elife_a_article_version_id', 'value', 'value');
    if ($results = $query->execute()) {
      foreach ($results['node'] as $nid => $data) {
        $emptys[$nid] = $data->extraFields->field_elife_a_article_version_id_value;
      }
    }
  }
  return $emptys;
}

/**
 * Get the total number of article versions (published or unpublished).
 *
 * @return int
 *   Integer of article versions in the systems
 */
function _elife_article_version_count() {
  $cache = &drupal_static(__FUNCTION__);

  if (is_null($cache)) {
    $query = new EntityFieldQueryExtraFields();
    $query->addTag('DANGEROUS_ACCESS_CHECK_OPT_OUT');
    $query->entityCondition('entity_type', 'node');
    $query->entityCondition('bundle', 'elife_article_ver');
    $query->fieldCondition('field_elife_a_subarticle', 'value', 0);
    if ($results = $query->execute()) {
      $cache = count($results['node']);
    }
  }

  return $cache;
}

/**
 * Implements hook_query_TAG_alter().
 *
 * Check whether the main text field has a NULL value.
 */
function elife_article_query_main_text_null_alter(QueryAlterableInterface $query) {
  $query->leftJoin('field_data_field_elife_a_main_text', 'm', 'node.nid = m.entity_id');
  $query->isNull('m.field_elife_a_main_text_value');
}

/**
 * Retrieve the article version ids for all article versions with no EIF Json.
 *
 * @param bool $force_empty
 *   If you want to consider all article versions as being empty set to FALSE.
 * @param int|NULL $limit
 *   Number of results to limit query to.
 * @param int|NULL $offset
 *   Offset for results.
 *
 * @return array
 *   Array of article version ids with the nid as a key.
 */
function _elife_article_empty_eif_json($force_empty = FALSE, $limit = NULL, $offset = NULL) {
  $emptys = [];
  $query = new EntityFieldQueryExtraFields();
  $query->addTag('DANGEROUS_ACCESS_CHECK_OPT_OUT');
  if (!$force_empty) {
    $query->addTag('eif_json_null');
  }
  $query->entityCondition('entity_type', 'node');
  $query->entityCondition('bundle', 'elife_article_ver');
  $results = $query->execute();
  if (!empty($results) && !empty($results['node'])) {
    $nids = array_keys($results['node']);
    $query = new EntityFieldQueryExtraFields();
    $query->addTag('DANGEROUS_ACCESS_CHECK_OPT_OUT');
    $query->entityCondition('entity_type', 'node');
    $query->entityCondition('bundle', 'elife_article_ver');
    $query->propertyCondition('nid', $nids, 'IN');
    $query->fieldCondition('field_elife_a_subarticle', 'value', 0);
    $query->addExtraField('field_elife_a_article_version_id', 'value', 'value');
    $query->addExtraField('field_elife_a_version', 'value', 'value');
    $query->addExtraField('field_elife_a_update', 'value', 'value');
    $query->addExtraField('', 'status', 'status', 'node');
    if (!is_null($limit) || !is_null($offset)) {
      $query->range($offset, $limit);
    }
    if ($results = $query->execute()) {
      foreach ($results['node'] as $nid => $data) {
        $emptys[$data->extraFields->field_elife_a_article_version_id_value] = [
          'nid' => $nid,
          'version' => $data->extraFields->field_elife_a_version_value,
          'update' => ($data->extraFields->status) ? strtotime($data->extraFields->field_elife_a_update_value) : NULL,
        ];
      }
    }
  }
  return $emptys;
}

/**
 * Implements hook_query_TAG_alter().
 *
 * Check whether the EIF Json field has a NULL value.
 */
function elife_article_query_eif_json_null_alter(QueryAlterableInterface $query) {
  $query->leftJoin('field_data_field_elife_a_eif_json', 'ej', 'node.nid = ej.entity_id');
  $query->leftJoin('field_data_field_elife_a_contributor_names', 'cn', 'node.nid = cn.entity_id');

  $db_or = db_or();

  $db_or->isNull('ej.field_elife_a_eif_json_value');
  $db_or->isNull('cn.field_elife_a_contributor_names_value');
  $query->condition($db_or);
}

/**
 * Retrieve result from cache or perform query.
 *
 * @param ElifeCitationService $citation
 *   Citation service container
 * @param bool $from_store
 *   Set to false if you don't want to try to retrieve from cache
 *
 * @return ElifeCitationService
 *   Citation service container
 */
function _elife_article_citation_query(ElifeCitationService $citation, $from_store = TRUE) {
  if ($from_store) {
    $cache = _elife_article_citation_query_cache($citation);
    $key = $citation->getId();
    if (!empty($cache[$key])) {
      $citation = $cache[$key];
    }
  }
  else {
    $citation->submitQuery();
  }

  return $citation;
}

/**
 * Retrieve citation request from cache or trigger query if not in cache.
 *
 * @param ElifeCitationService $citation
 *   Citation service container
 *
 * @return ElifeCitationService[]
 *   Array of citation service containers that have been queried
 *
 * @throws Exception
 */
function _elife_article_citation_query_cache(ElifeCitationService $citation) {
  $cache = &drupal_static(__FUNCTION__, []);
  if (!empty($citation->getId())) {
    $key = $citation->getId();
    if (!isset($cache[$key])) {
      $result = cache_get($key, 'cache_elife_citation');

      if (!empty($result->data)) {
        $citation = unserialize($result->data);
      }
      else {
        _elife_article_citation_cache_merge($citation);
      }
      $cache[$key] = $citation;
    }
  }

  return $cache;
}

/**
 * Populate the cache for a specific citation request.
 *
 * @param ElifeCitationService $citation
 *   Citation service container
 *
 * @throws Exception
 * @throws InvalidMergeQueryException
 */
function _elife_article_citation_cache_merge(ElifeCitationService $citation) {
  $key = $citation->getId();
  $citation->submitQuery();
  cache_set($key, serialize($citation), 'cache_elife_citation');
}

/**
 * Warm the cache for specific article versions.
 *
 * @param array|string $article_version_ids
 *   Article version ids
 */
function _elife_article_citation_cache_warm($article_version_ids) {
  if (!is_array($article_version_ids)) {
    $article_version_ids = [$article_version_ids];
  }
  _elife_article_citation_cache_clear($article_version_ids);

  foreach ($article_version_ids as $article_version_id) {
    $citation = elife_article_citation_service();
    $citation->setId($article_version_id);
    _elife_article_citation_query($citation);
  }
}

/**
 * Clear the citation cache for specific article versions.
 *
 * @param array|string $article_version_ids
 *   Article version ids
 */
function _elife_article_citation_cache_clear($article_version_ids) {
  if (!is_array($article_version_ids)) {
    $article_version_ids = [$article_version_ids];
  }

  foreach ($article_version_ids as $article_version_id) {
    cache_clear_all($article_version_id, 'cache_elife_citation');
  }
}

/**
 * Empty all entries in the citation query cache table.
 */
function _elife_article_citation_cache_clear_all() {
  $cache = &drupal_static(__FUNCTION__, FALSE);
  if (empty($cache)) {
    cache_clear_all(NULL, 'cache_elife_citation');
    $cache = TRUE;
  }
  return $cache;
}

/**
 * Retrieve the markup for a specific request.
 *
 * @param ElifeMarkupService $markup
 *   Markup service container
 *
 * @return string
 *   Key to be used for markup service query
 */
function _elife_article_markup_query_key(ElifeMarkupService $markup) {
  return md5(serialize($markup->getQuery()));
}

/**
 * Retrieve result from cache or perform query.
 *
 * @param ElifeMarkupService $markup
 *   Markup service container
 * @param bool $from_store
 *   Set to false if you don't want to try to retrieve from cache
 *
 * @return ElifeMarkupService
 *   Markup service container
 */
function _elife_article_markup_query(ElifeMarkupService $markup, $from_store = TRUE) {
  if ($from_store) {
    $cache = _elife_article_markup_query_cache($markup);
    $key = _elife_article_markup_query_key($markup);
    if (!empty($cache[$key])) {
      $markup = $cache[$key];
    }
  }
  else {
    $markup->submitQuery();
  }

  return $markup;
}

/**
 * Retrieve markup request from cache or trigger query if not in cache.
 *
 * @param ElifeMarkupService $markup
 *   Markup service container
 *
 * @return ElifeMarkupService[]
 *   Array of markup service containers that have been queried
 *
 * @throws Exception
 */
function _elife_article_markup_query_cache(ElifeMarkupService $markup) {
  $cache = &drupal_static(__FUNCTION__, []);
  if (!empty($markup->getQuery())) {
    $key = _elife_article_markup_query_key($markup);
    if (!isset($cache[$key])) {
      $article_version_ids = array_keys($markup->getQuery());
      $article_version_id = reset($article_version_ids);
      $prepare_markup = _elife_article_markup_query_article_version_id($article_version_id);

      $new = TRUE;
      if ($prepare_markup) {
        // If this query is found in the markup object then we will not need to
        // store anything at the end of the page request for this query.
        if ($prepare_markup instanceof ElifeXslMarkupService && $prepare_markup->archiveFound($key)) {
          $new = FALSE;
        }
        $prepare_markup->load($markup);
      }
      else {
        $prepare_markup = $markup;
      }

      if ($new) {
        _elife_article_markup_query_article_version_id($article_version_id, $prepare_markup);
      }

      $cache[$key] = $prepare_markup;
    }
  }

  return $cache;
}

/**
 * Get or load the markup object for an article version.
 *
 * @param null $article_version_id
 * @param null $markup
 * @return bool
 */
function _elife_article_markup_query_article_version_id($article_version_id = NULL, $markup = NULL) {
  static $cache = [];
  // If no article version id provided then retrieve the stored values.
  if (is_null($article_version_id)) {
    return $cache;
  }
  // If markup object is provided then assume that we want to store.
  elseif (!is_null($markup)) {
    $cache[$article_version_id] = $markup;
    _elife_article_markup_query_article_version_id_store($article_version_id, TRUE);
  }
  // If we have not retrieved markup object from database in this page request
  // then retrieve from cache table.
  elseif (!isset($cache[$article_version_id])) {
    $result = cache_get($article_version_id, 'cache_elife_markup');
    if (!empty($result->data)) {
      $cache[$article_version_id] = unserialize($result->data);
    }
  }

  // Get markup object from cache store.
  if (isset($cache[$article_version_id])) {
    return $cache[$article_version_id];
  }
  else {
    return FALSE;
  }
}

/**
 * Allow a flag to be set if new markup queries are performed for an article
 * version.
 *
 * @param $article_version_id
 * @param null $set_store
 * @return bool
 */
function _elife_article_markup_query_article_version_id_store($article_version_id, $set_store = NULL) {
  static $store = [];
  if (!is_null($set_store)) {
    $store[$article_version_id] = $set_store;
  }

  if (!isset($store[$article_version_id])) {
    return FALSE;
  }

  return $store[$article_version_id];
}

/**
 * Implements hook_page_alter().
 */
function elife_article_page_alter(&$page) {
  // Determine if we need to write markup to store for article versions.
  $markup_queries = _elife_article_markup_query_article_version_id();
  if (is_array($markup_queries)) {
    foreach ($markup_queries as $article_version_id => $markup) {
      if (_elife_article_markup_query_article_version_id_store($article_version_id)) {
        _elife_article_markup_cache_merge($markup, FALSE);
      }
    }
  }
}

/**
 * Populate the cache for a specific markup request.
 *
 * @param ElifeMarkupService $markup
 *   Markup service container
 * @param bool $submit
 *   Submit query prior to storing.
 *
 * @throws Exception
 * @throws InvalidMergeQueryException
 */
function _elife_article_markup_cache_merge(ElifeMarkupService $markup, $submit = TRUE) {
  $article_version_ids = array_keys($markup->getQuery());
  $article_version_id = reset($article_version_ids);
  if ($submit) {
    $markup->submitQuery();
  }
  cache_set($article_version_id, serialize($markup), 'cache_elife_markup');
  _elife_article_markup_query_article_version_id_store($article_version_id, FALSE);
}

/**
 * Warm the cache for specific article versions.
 *
 * @param array|string $article_version_ids
 *   Article version ids
 */
function _elife_article_markup_cache_warm($article_version_ids) {
  if (!is_array($article_version_ids)) {
    $article_version_ids = [$article_version_ids];
  }

  foreach ($article_version_ids as $article_version_id) {
    $result = cache_get($article_version_id, 'cache_elife_markup');
    $queries = [];
    if (!empty($result->data)) {
      $markup = unserialize($result->data);
      if (!empty($markup->archive)) {
        foreach ($markup->archive as $archive) {
          $queries[] = $archive['queries'];
        }
      }
      _elife_article_markup_cache_clear($article_version_id);
    }

    $markup = elife_article_markup_service();
    if (empty($queries)) {
      $sections = [
        'abstract',
        'digest',
        'main-text',
        'references',
        'acknowledgements',
        'decision-letter',
        'author-response',
      ];
      foreach ($sections as $section) {
        $markup->addSectionQuery($article_version_id, $section);
      }
      _elife_article_markup_query($markup);
    }
    else {
      foreach ($queries as $items) {
        $markup->recoverResults(['queries' => $items]);
        _elife_article_markup_query($markup);
      }
    }
  }
}

/**
 * Clear the markup cache for specific article versions.
 *
 * @param array|string $article_version_ids
 *   Article version ids
 */
function _elife_article_markup_cache_clear($article_version_ids) {
  if (!is_array($article_version_ids)) {
    $article_version_ids = [$article_version_ids];
  }

  foreach ($article_version_ids as $article_version_id) {
    cache_clear_all($article_version_id, 'cache_elife_markup');
  }
}

/**
 * Empty all entries in the markup query cache table.
 */
function _elife_article_markup_cache_clear_all() {
  $cache = &drupal_static(__FUNCTION__, FALSE);
  if (empty($cache)) {
    cache_clear_all(NULL, 'cache_elife_markup');
    $cache = TRUE;
  }
  return $cache;
}

/**
 * Clear markup cache if request value found.
 *
 * @param string $article_version_id
 * @param bool $bypass_access
 * @return array
 */
function elife_article_markup_clear_once($article_version_id, $bypass_access = FALSE) {
  $cache = &drupal_static(__FUNCTION__, []);
  if ($bypass_access || (user_access('clear elife_article markup')) && !isset($cache[$article_version_id])) {
    $cache[$article_version_id] = TRUE;
    _elife_article_markup_cache_clear($article_version_id);
    _elife_article_citation_cache_clear($article_version_id);
    drupal_set_message(t('elife_markup cleared for article !article_version_id', ['!article_version_id' => $article_version_id]));
  }
  return $cache;
}

/**
 * Trigger clear up of article version markup.
 *
 * @param $node
 */
function _elife_article_markup_clear($node) {
  $dto = elife_article_version_to_dto($node);
  elife_article_markup_clear_once($dto->getArticleVersionId());
  if (!empty($_GET['destination'])) {
    $path = $_GET['destination'];
    unset($_GET['destination']);
  }
  else {
    $path = 'node/' . $node->nid;
  }
  drupal_goto($path);
}

/**
 * Get pmid from doi.
 *
 * @param string $doi
 *
 * @return string|null
 */
function elife_article_doi_to_pmid($doi) {
  $cache = elife_article_doi_to_pmid_cache($doi);
  $data = $cache[$doi];

  if (!empty($data)) {
    return $data->records[0]->pmid;
  }
}

/**
 * Get cached results for pmid queries.
 *
 * @param string $doi
 *
 * @return array
 */
function elife_article_doi_to_pmid_cache($doi) {
  $doi_to_pmid_cache = &drupal_static(__FUNCTION__, array());

  if (!isset($doi_to_pmid_cache[$doi])) {
    $cache_bin = 'cache_elife_article_pmid';
    $data = FALSE;
    if ($cache = cache_get($doi, $cache_bin)) {
      if (!empty($cache->data)) {
        $data = $cache->data;
      }
    }

    if (empty($data)) {
      $request_uri = 'https://www.ncbi.nlm.nih.gov/pmc/utils/idconv/v1.0/?format=json&ids=' . $doi;
      if ($result = drupal_http_request($request_uri, ['timeout' => DEFAULT_HTTP_TIMEOUT])) {
        // Only store the data if pmid found.
        if(empty($result->error)) {
          $verify = json_decode($result->data);
          if (isset($verify->records[0]->pmid)) {
            $data = $result->data;
            cache_set($doi, $data, $cache_bin);
          }
        }
      }
    }
    $doi_to_pmid_cache[$doi] = json_decode($data);
  }

  return $doi_to_pmid_cache;
}

/**
 * Get glencoe API data from doi.
 *
 * @param string $doi
 *
 * @return object|null
 */
function elife_article_doi_to_glencoe_data($doi) {
  $cache = elife_article_doi_to_glencoe_data_cache($doi);
  $data = $cache[$doi];

  if (!empty($data)) {
    return $data;
  }
}

/**
 * Get cached results for glencoe API queries.
 *
 * @param string $doi
 *
 * @return array
 */
function elife_article_doi_to_glencoe_data_cache($doi) {
  $doi_to_glencoe_api_cache = &drupal_static(__FUNCTION__, array());

  if (!isset($doi_to_glencoe_api_cache[$doi])) {
    $cache_bin = 'cache_elife_article_glencoe';
    $data = FALSE;
    if ($cache = cache_get($doi, $cache_bin)) {
      if (!empty($cache->data)) {
        $data = $cache->data;
      }
    }

    if (empty($data)) {
      $request_uri = variable_get('elife_article_source_assets_glencoe_api') . $doi;
      if ($result = drupal_http_request($request_uri, ['timeout' => DEFAULT_HTTP_TIMEOUT])) {
        $data = $result->data;
        cache_set($doi, $result->data, $cache_bin);
      }
    }
    $doi_to_glencoe_api_cache[$doi] = json_decode($data);
  }

  return $doi_to_glencoe_api_cache;
}

/**
 * Implements hook_field_create_field().
 */
function elife_article_field_create_field($field) {
  if ('field_elife_a_doi' === $field['field_name']) {
    db_add_index('field_data_field_elife_a_doi', 'elife_type_value', [
      'entity_type',
      'field_elife_a_doi_value',
    ]);
  }
}

/**
 * Delete existing article version.
 *
 * @param ArticleVersion $article_version
 */
function elife_article_delete_existing(ArticleVersion $article_version) {
  elife_article_delete_existing_path($article_version->getPath());
}

/**
 * Delete existing article version by path.
 *
 * @param string $path
 */
function elife_article_delete_existing_path($path) {
  $query = db_select('url_alias', 'ua');
  $query->fields('ua', ['pid', 'alias']);
  $query->addField('n', 'nid');
  $db_or = db_or();
  $db_or->condition('ua.alias', $path);
  $db_or->condition('ua.alias', $path . '/%', 'LIKE');
  $query->condition($db_or);
  $query->leftJoin('node', 'n', "CONCAT('node/', n.nid) = ua.source");
  if ($results = $query->execute()->fetchAllAssoc('pid')) {
    pathauto_path_delete_multiple(array_keys($results));
    $nids = [];
    foreach ($results as $result) {
      if (!empty($result->nid)) {
        $nids[] = $result->nid;
      }
    }
    if (!empty($nids)) {
      node_delete_multiple($nids);
    }
  }
}

/**
 * Return an array of duplicate elife_article and elife_article_reference nodes.
 *
 * @return array
 */
function elife_article_detect_duplicates() {
  $results = [];
  foreach (['elife_article', 'elife_article_reference'] as $type) {
    $query = db_select('node', 'n');
    $query->addField('aid', 'field_elife_a_article_id_value', 'article_id');
    // Duplicate entry nid values.
    $query->addExpression('GROUP_CONCAT(n.nid ORDER BY n.nid DESC)', 'nids');
    // Status of the duplicate entry nodes.
    $query->addExpression("GROUP_CONCAT(n.status ORDER BY n.nid DESC SEPARATOR '')", 'status');
    $query->addExpression('COUNT(n.nid)', 'duplicates');
    $query->condition('n.type', $type);
    $query->innerJoin('field_data_field_elife_a_article_id', 'aid', 'aid.entity_id = n.nid');
    $query->groupBy('aid.field_elife_a_article_id_value');
    $query->having('COUNT(n.nid) > 1');
    $query->orderBy('COUNT(n.nid)', 'DESC');
    $query->orderBy('article_id', 'ASC');
    if ($type_results = $query->execute()->fetchAllAssoc('article_id')) {
      $results[$type] = $type_results;
    }
  }

  foreach (['elife_article_ver', 'elife_fragment'] as $type) {
    $query = db_select('node', 'n');
    $query->condition('n.type', $type);
    $query->innerJoin('url_alias', 'ua1', "ua1.source = CONCAT('node/', n.nid)");
    $query->innerJoin('url_alias', 'ua2', "ua2.alias = ua1.alias");
    $query->leftJoin('field_data_field_elife_a_subarticle', 'sub', "sub.entity_id = n.nid AND sub.entity_type = 'node' AND sub.bundle = n.type");
    $query->where('ua1.source != ua2.source');
    // Duplicate entry nid values.
    $query->addExpression('GROUP_CONCAT(n.nid ORDER BY n.nid DESC)', 'nids');
    // Status of the duplicate entry nodes.
    $query->addExpression("GROUP_CONCAT(n.status ORDER BY n.nid DESC SEPARATOR '')", 'status');
    $query->addExpression('ua1.alias', 'ua_alias');
    $query->groupBy('ua1.alias');
    if ($type_results = $query->execute()->fetchAllAssoc('ua_alias')) {
      $results[$type] = $type_results;
    }
  }

  return $results;
}

/**
 * Detect elife_article nodes with a version weight inconsistency.
 *
 * @return array
 */
function elife_article_detect_version_inconsistencies() {
  static $results = NULL;

  if (is_null($results)) {
    $results = [];

    $query = db_select('field_data_field_elife_a_versions', 'v');
    $query->addField('v', 'entity_id');
    $query->addExpression('SUM(v.delta)', 'delta_sum');
    $query->addExpression('(POW(COUNT(v.entity_id), 2) - COUNT(v.entity_id))/2', 'expected_delta_sum');
    $query->addExpression('GROUP_CONCAT(v.delta ORDER BY v.delta ASC)', 'weights');
    $query->addExpression('COUNT(v.entity_id)', 'versions');
    $query->addField('d', 'field_elife_a_doi_value', 'doi');
    $query->innerJoin('field_data_field_elife_a_doi', 'd', 'd.entity_id = v.field_elife_a_versions_target_id');
    $query->groupBy('v.entity_id');
    $query->having('delta_sum <> expected_delta_sum');
    $query->orderBy('d.field_elife_a_doi_value');
    if ($inconsitstency_results = $query->execute()->fetchAllAssoc('entity_id')) {
      $results = $inconsitstency_results;
    }
  }
  return $results;
}

/**
 * Saving the nodes will resolve the version weights.
 *
 * @param object[] $nodes
 */
function elife_article_resolve_version_weights($nodes) {
  foreach ($nodes as $node) {
    node_save($node);
  }
}

/**
 * Detect and resolve article version weight inconsistencies.
 */
function elife_article_detect_and_resolve_version_weight_inconsistencies() {
  $version_inconsistencies = elife_article_detect_version_inconsistencies();
  if (!empty($version_inconsistencies)) {
    $nodes = node_load_multiple(array_keys($version_inconsistencies));
    elife_article_resolve_version_weights($nodes);
  }
}

/**
 * Return a list of entityreference field that target elife_article_reference
 *
 * @return array
 */
function elife_article_target_reference_fields() {
  $er_fields = field_read_fields(['type' => 'entityreference']);
  foreach ($er_fields as $field_name => $field_info) {
    if (strrpos($field_name, 'field_elife_', -strlen($field_name)) === FALSE || !isset($field_info['settings']['handler_settings']['target_bundles']['elife_article_reference'])) {
      unset($er_fields[$field_name]);
    }
  }
  return $er_fields;
}

/**
 * Resolve the duplicate elife_article and elife_article_reference nodes.
 *
 * @throws \Exception
 */
function elife_article_resolve_duplicates() {
  $duplicates = elife_article_detect_duplicates();
  if (!empty($duplicates)) {
    $map_nids = [];
    $exclude_nids = [];
    foreach ($duplicates as $type => $type_duplicates) {
      foreach ($type_duplicates as $article_id => $type_dupl) {
        $nids = explode(',', $type_dupl->nids);
        // Find out the position of the first published duplicate node.
        $published = strpos($type_dupl->status, '1');
        // Index of the nid in the nids array to consider current.
        $current_index = (in_array($type, ['elife_article', 'elife_article_reference']) && $published !== FALSE) ? $published : 0;
        // The node nid to preserve.
        $current_nid = $nids[$current_index];
        // Combine array of duplicate node nids mapped to the current node nid.
        $map_nids += array_combine($nids, array_fill(0, count($nids), $current_nid));
        // We plan to exclude the current nid from our mapping as it is already
        // correct.
        $exclude_nids[] = $current_nid;
      }
    }
    $map_nids = array_diff_key($map_nids, array_flip($exclude_nids));

    if (!empty($map_nids)) {
      $er_fields = elife_article_target_reference_fields();
      foreach ($er_fields as $field_name => $field_info) {
        // For each reference field return results for those that target
        // duplicated nodes.
        $efq = new EntityFieldQueryExtraFields();
        $efq->fieldCondition($field_name, 'target_id', array_keys($map_nids), 'IN');
        $efq->addExtraField($field_name, 'target_id', 'target_id');
        $efq->addTag('resolve_duplicates');

        $results = $efq->execute();
        if (!empty($results['node'])) {
          foreach ($results['node'] as $nid => $result) {
            $node = node_load($nid);
            $node->{$field_name}[LANGUAGE_NONE][$result->extraFields->delta]['target_id'] = $map_nids[$result->extraFields->{$field_name . '_target_id'}];
            node_save($node);
          }
        }
      }
    }

    node_delete_multiple(array_keys($map_nids));
  }

  // Because we may be deleting duplicate elife_article nodes, their
  // corresponding elife_article_reference nodes will have become unpublished
  // as a result so we need to resolve that.
  elife_article_resolve_published_status();
}

/**
 * Return an array of elife_article nodes what have a different publication
 * status to their corresponding elife_article_reference (default) node.
 *
 * @param string $type
 *   Node type to query. Should be elife_article_reference or elife_article_ver.
 *
 * @return array|NULL
 */
function elife_article_detect_different_published_status($type = 'elife_article_reference') {
  $query = db_select('node', 'n');
  $query->addExpression('GROUP_CONCAT(n.nid ORDER BY n.status DESC)', 'article_nids');
  $query->addField('n', 'type');
  $query->addExpression('MAX(n2.status)', 'diff_status');
  $query->addField('n2', 'status');
  $query->innerJoin('field_data_field_elife_a_article_id', 'aid', 'aid.entity_id = n.nid');
  if ($type == 'elife_article_reference') {
    $query->innerJoin('node', 'n2', "n2.title = CONCAT(aid.field_elife_a_article_id_value, ': ', n.title)");
  }
  else {
    $query->innerJoin('node', 'n2', "n2.title = n.title");
  }
  $query->condition('n.type', 'elife_article');
  $query->condition('n2.type', $type);
  $query->groupBy('n.title');
  $query->groupBy('n2.title');
  $query->having('MAX(n.status) <> MAX(n2.status)');
  if ($results = $query->execute()->fetchAllAssoc('article_nids')) {
    return $results;
  }
}

/**
 * Resolve the elife_article_reference nodes that don't have the same published
 * status as their corresponding elife_article node. Also resolve the article
 * nodes that aren't published when there exists a published elife_article_ver
 * node.
 *
 * @throws \Exception
 */
function elife_article_resolve_published_status() {
  // Saving the elife_article nodes will trigger the appropriate hook so that
  // the corresponding elife_article_reference nodes have the same published
  // status.
  if ($different = elife_article_detect_different_published_status()) {
    $article_nids = implode(',', array_keys($different));
    $article_nids = explode(',', $article_nids);
    if (!empty($article_nids)) {
      $nodes = node_load_multiple($article_nids);
      foreach ($nodes as $node) {
        node_save($node);
      }
    }
  }

  // Set the article nodes to the same status as the MAX of the corresponding
  // elife_article_ver nodes.
  if ($different = elife_article_detect_different_published_status('elife_article_ver')) {
    foreach ($different as $article_nids => $item) {
      $article_nids = explode(',', $article_nids);
      $article_nids = array_unique($article_nids);
      $nodes = node_load_multiple($article_nids);
      foreach ($nodes as $node) {
        $node->status = ($item->diff_status) ? NODE_PUBLISHED : NODE_NOT_PUBLISHED;
        node_save($node);
      }
    }
  }
}

/**
 * Add the delta field to the select query.
 *
 * Implements hook_query_TAG_alter().
 */
function elife_article_query_resolve_duplicates_alter(QueryAlterableInterface $query) {
  $query->addExpression('delta', 'delta');
}
